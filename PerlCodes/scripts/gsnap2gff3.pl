#!/usr/bin/perl -w

# File: gsnap2gff3.pl
# Author: Eddy Yeh
#
# Description: This program parses the alignment output produced by GSNAP from paired/unpaired reads
#              into GFF3 and SAM file format considering variable mismatch counts per read based on their read length
#
# Recommended GSNAP Parameters:
#   SINGLE-END: % gsnap -D <db_dir> -d <db_name> -B 5 -m 10 -i 2 -N 1 -n 3 -t 24 --quality-protocol=illumina --nofails input.fq > out.gsnap
#   PAIRED-END: % gsnap -D <db_dir> -d <db_name> -B 5 -m 10 -i 2 -N 1 -n 3 -t 24 --quality-protocol=illumina --nofails mate1.fq mate2.fq > out.gsnap 
#   NOTES:
#       Change -B 2 to -B 5 if your system has enough memory       
#       Change -t 24 to the total number of processors to use for alignment
#       Change --quality-protocol value to 'illumina' or 'sanger' accordingly
#       Change -N 1 to -N 0 for RNA-seq or genomic reads (-N 1 = RNA-seq ; -N 0 = Genomic, turns off splicing)
#
# Change Log v0.20 (2012.07.12 -- Eddy)
#   - Fixed bug determining best possible alignment for each mate
#
# Change Log v0.19 (2012.06.02 -- Eddy)
#   - Fixed bug when parsing splice distance information from alignment files generated by old versions of GSNAP
#
# Change Log v0.18 (2012.01.05 -- Eddy)
#   - Fixed TLEN sign for paired-end reads in SAM output. The leftmost segment has a plus sign and the rightmost has a minus sign
#
# Change Log v0.17 (2011.11.17 -- Eddy)
#   - GSNAP standard output sometimes fail to identify "silent" insertions/deletions count in their attributes column that caused SAM output's CIGAR string to become
#     incompatible with the sequence length. Additional code has been added to address this issue
#   - Fixed small bug tht failed to obtain accurate splice distance when a read has 2 or more splice sites
#   - Removed program parameter --legacy, no longer needed
#
# Change Log v0.16 (2011.11.01 -- Eddy)
#   - Fixed parsing problem when used with newer versions of GSNAP.
#   - Parsing of GSNAP output produced prior to the 2011-10-16 release can be controlled with --legacy flag. This
#     flag was implemented due to old GSNAP producing improper output that caused formatting to SAM nearly imposible.
#     If this flag is specified, the records that shows strangeness will be discarded. I've inspected manually the
#     alignment coordinates of those strange reads and they seem to be improperly aligned. Newer versions of GSNAP
#     will align more accurately in other regions of the genome.
#
# Change Log v0.15 (2011.10.18 -- Eddy)
#   - Performance optimizations and code cleanup
#   - No longer needed to specify paired-end or single-end input files, -pe and -se arguments removed. Use --input|-i instead
#
# Change Log v0.14 (2011.09.14 -- Eddy)
#   - Incorporated XS and XT flags when parsing standard GSNAP output to SAM output
#   - Changed how bitwise flag is computed for SAM output
#   - Added parsing read alignments with variable tail length allowed based on the read
#     length (see --tail option)
#
# Change Log v0.13 (2011.07.12 -- Eddy)
#   - Removed support to output parsed alignments in tabular form
#   - Changed single end GSNAP output file parsing --input to --single|-se
#   - Added parameter --paired|-pe to support parsing of paired-end alignments
#   - Allows input of multiple single-end and paired-end files
#   - Increase intron splicing size to 100,000 from 10,000
#
# Change Log v0.12 (2011.05.18 -- Eddy)
#   - Added additional output option (--format sam) to parse results in SAM output format. If this option is specified
#     an additional parameter (-l <reference sequence length>) file must be present. Reference sequence file
#     is a tab delimited plain text file in which the first column is the reference id and the sequence column
#     is the length in base-pairs.
#
# Change Log v0.11 (2011.03.16 -- Eddy)
#   - Fix problems when parsing quality scores introducted in GSNAP 2011-03-11
#
# Change Log v0.10 (2011.03.14 -- Eddy)
#   - Added the reporting to the output file the total aligned reads when --best/--unique parsing is specified
#
# Change Log v0.09 (2011.03.07 -- Eddy)
#   - Implemented parsing using virtual processors to speed up the process. Added program parameter --processors|-p
#   - Added parameter --output as requirement to save parsed results intead of standard output
#   - Added program parameter --format tabublar|gff3 to parse results in different output formats. Default
#     parsing is to GFF3 file
#
# Change Log v0.08 (2011.03.04 -- Eddy)
#   - Changed program parameter --maxtail to --tail
#   - Performance optimizations
# 
# Change Log v0.07 (2010.11.16 -- Eddy)
#   - Added aligned read counts at the end of the output gff3 file
#
# Change Log v0.06 (2010.11.13 -- Eddy)
#   - Removed --imr parsing option from program parameters and replaced with --idp (indel penalty). Default value
#     of --idp is 2 in terms of mismatches (+1 for GAP opening alignment and +1 for the consecutive INDEL stretch)
#   - Changed default maximum tail allowed per read (--maxtail) option to 3. By default, allow 3 nucleotides as
#     combined tail per read
#   - Changed default mismatch criteria to 2 36. By default, program will treat the reads to have uneven length
#     due to pre-reads trimming executed before alignment
#
# Change Log v0.05 (2010.11.03 -- Eddy)
#   - Added program argument --imr (INDEL Mismatch ratio) to strenghten INDEL penalty when parsing
#     Before, each inserted/deleted base was treated as a mismatch. With --imr option, we can know adjust
#     the weight of each INDEL in terms of mismatch more accurately.
#   - Added program argument --ignoretail. When specified, tails are ignored and not counted as read mismatches
#   - Added program argument --maxtail. When specified, tails are not counted as mismatches and only the reads
#     having tails <= maxtail will be considered as 'good' aligned
#
# Change Log v0.04 (2010.06.29 -- Eddy)
#   - Splice translocation, inversion, and scramble of reads produces incorrect parsing results. For this
#     reason, if translocation, inversion, and/or scramble is present, the read/path is ignored
#   - Added program parameter -k for maximum splice distance allowed
#
#   The example above shows that a transcript splice alignment is in 2 different chromosomes and differnt strands.
#   Read validation step now takes care of this problem
#
# Change Log v0.03 (2010.06.22 -- Eddy)
#   - GSNAP considers ambiguous nucleotides (i.e. N) as substitutions, recompute the total number of
#     substitutions per read allowing Ns as matches instead of substitutions
#
# Change Log v0.02 (2010.06.21 -- Eddy)
#   - Bug fix: substitutions were not properly talled when a read had insertions/deletions.
#
# Change Log v0.01 (2010.06.10 -- Eddy)
#   - Re-implementation of the script after better understanding GSNAP output format. Includes the talling
#     of insertions, deletions, tails, etc.
#   - Implementation of variable mismatch numbers according to the length of the read
#   - Removed implementation of filtering reads based on their percentages

use strict;
use warnings;
use FileHandle;
use Getopt::Long;
use POSIX qw(floor ceil);
use Parallel::ForkManager 0.7.6;
use Digest::MD5 qw(md5_hex);
use Term::ANSIColor;
use Time::Local;

use constant VERSION => "0.20 (2012.07.12)";
use constant true => 1;
use constant false => 0;
use constant DEFAULT_MISMATCHES => 2;			# Default maximum mismatches of variable read lengths
use constant DEFAULT_MISMATCHES_LENGTH => 36;	# Default length to consider mismatches.
												# Note: DEFAULT_MISMATCHES and DEFAULT_MISMATCHES_LENGTH are combined
												# when parsing (allow 2 mismatches per every 36 bp of read length)
use constant DEFAULT_TAIL => 5;					# Default maximum mismatches of variable read lengths
use constant DEFAULT_TAIL_LENGTH => 75;			# Default length to consider tails
use constant DEFAULT_IDP => 2;					# Default INDEL penalty
use constant DEFAULT_SOURCE => "GSNAP";			# Default source string to be used in GFF3 file
use constant MAXIMUM_SPLICE_DISTANCE => 100000;	# Maximum splice distance allowed
use constant DEFAULT_PROCESSORS_COUNT => 1;     # Default number of processors to use when parsing
use constant DEFAULT_OUTPUT_FORMAT => "gff3";	# Default output format

# Returns an unique identifier for temporary files
sub generateID {
	my $str = md5_hex(scalar(localtime(time)) . $$);
	return $str;
} # End of sub generateID

# Formats the parametric number adding the commas every thousands, millions, etc
sub formatNumber {
    local($_) = shift;
    1 while s/^(-?\d+)(\d{3})/$1,$2/;

    return $_; 
} # End of sub formatNumber

# remove leading and trailing white space characters from string
sub trim {
    my $str = $_[0];
    
    if (defined($str)) {
        $str =~ s/^(\s+|\t+)//g;
        $str =~ s/(\s+|\t+)$//g;
    } # End of if statement

    return $str;
} # End of sub trim

# takes the reverse complement of a sequence
sub reverseComplement {
    my $seq = reverse($_[0]);
    $seq =~ tr/AGCT/TCGA/;
    return $seq;
} # End of sub reverseComplement

# Format seconds notation into hours:mins:seconds
sub formatTime {
    my $totaltime = $_[0];
    my $str;

    $str = sprintf("%02d:", $totaltime / 3600);    # total hours
    $totaltime = $totaltime % 3600;
    $str .= sprintf("%02d:", $totaltime / 60);      # total minutes
    $totaltime = $totaltime % 60;  
    $str .= sprintf("%02d", $totaltime);            # total sconds
    return $str;
} # End of sub formatTime

# returns the minimum value from an array of numbers
sub min {
	my @sorted = sort {$a <=> $b} @_;
	return shift(@sorted);
} # End of sub min

# returns the maximum value from an array of numbers
sub max {
	my @sorted = sort {$a <=> $b} @_;
	return pop(@sorted);
} # End of sub max

# Goes thru the input file once and determine the number of features (lines that start with ">")
sub countFeatures {
	my $input = $_[0];
	my $features = 0;

	my $fh = new FileHandle();
	open ($fh, $input) or die("Cannot open input file $input\n");
	while (<$fh>) {
		chomp;
		$features++ if ($_ =~ m/^>/);
	} # end of while loop
	close ($fh);

	return $features;
} # end of sub countFeatures

# Splits the input file into "processor" pieces for each processor
sub splitInputFile {
	my ($input, $processors) = @_;
	my $id = &generateID();	# Generates an unique identifier
	my @tmpFiles;

	my $features = &countFeatures($input);	# Count number of features before splitting
	my $perProc = ceil($features / $processors);
	my $num = 0;
	my $count = 0;

	my $ofh;	# For writing temporary file
	
	my $fh = new FileHandle();
	open ($fh, $input) or die("Cannot open input file $input\n");
	
	while (<$fh>) {
		chomp;
		if ($_ =~ m/^>/) {
			if ($count == 0 || $count % $perProc == 0) {
				close ($ofh) if (defined($ofh));	# Close previous file handle
				$ofh = new FileHandle();
				my $outfile = sprintf(".%s.p%02d", $id, $num);
				push(@tmpFiles, $outfile);

				open ($ofh, sprintf(">%s", $outfile)) or die("Cannot open temporary output file\n");
				$num++;
			} # end of if statement

			print $ofh sprintf("%s\n", $_);
			$count++;
		} # end of if statement
		else {
			print $ofh sprintf("%s\n", $_);
		} # end of else statement
	} # end of while loop
	close ($fh);
	close ($ofh) if defined($ofh);

	return @tmpFiles;
} # end of sub splitInputFile

# Returns the EST coordinates of the alignment
sub getESTCoords {
	my ($name, $coords) = @_;
	my ($start, $end);

	if ($coords =~ m/^(\d+)\.\.(\d+)$/) {
		$start = $1;
		$end = $2;
	} # End of if statement
	else {
		print STDERR sprintf("\n");
		print STDERR sprintf("     ERROR: INVALID EST COORDINATES OF READ '%s' : %s\n", $name, $coords);
		print STDERR sprintf("\n");
		exit();
	} # end of else statement

	return ($start, $end);
} # End of getESTCoords

# returns the Genomic coordinates of the alignment
sub getGenomicCoords {
    my ($name, $coords) = @_;
    my ($strand, $genomic, $start, $end);

    if ($coords =~ m/^(\+|-)(\S+):(\d+)\.\.(\d+)$/) {
        $strand = $1;
        $genomic = $2;
		$start = $3;
		$end = $4;
		
		# replace chr0 as chrUNKNOWN
		if ($genomic =~ m/^chr0$/i) {
			$genomic = "chrUNKNOWN";
		} # end of if statement
    } # End of if statement
    else {
        print STDERR sprintf("\n");
        print STDERR sprintf("     ERROR: INVALID GENOMIC COORDINATES FOR READ '%s' : %s\n", $name, $coords);
        print STDERR sprintf("\n");
        exit();
    } # End of else statement

    return ($strand, $genomic, $start, $end);
} # End of sub getGenomicCoords 

# Returns the mapping quality score reported by GSNAP. If the score is missing, a value of 255 is returned
sub getMappingQuality {
	my $score = $_[0];
	my $value = 255;	# Default mapping quality value

	if ($score =~ m/mapq:(\d+)/i) {
		$value = $1;
	} # end of if statement

	return $value;
} # end of sub getMappingQuality

# Returns the insert length reported by GSNAP for PE alignments. A value of zero is returned if missing
sub getInsertLength {
	my $fragment_attributes = $_[0];
	my $value = 0;

	if ($fragment_attributes =~ m/insert_length:(\d+)/i) {
		$value = $1;
	} # end of if statement

	return $value;
} # end of sub getInsertLength

# returns true if splice translocation, false otherwise
sub isSpliceTranslocationInversionScramble {
    my ($name, $attributes) = @_;
	my $translocation_inversion_scramble = false;

    if ($attributes =~ m/splice_(translocation|inversion|scramble)/i ||
        $attributes =~ m/splice_type:(translocation|inversion|scramble)/i) {
        $translocation_inversion_scramble = true;
    } # End of if statement

    return $translocation_inversion_scramble;
} # End of sub isSpliceTranslocationInversionScramble

# Get the corresponding values of matches, substiutions, insertions, and/or deletions
sub getPolymorphisms {
	my ($name, $est_start, $est_end, $est_sequence, $genomic_sequence, $attributes) = @_;
	my ($matches, $sub, $ins, $del, $n_count, $splice) = (0, 0, 0, 0, 0, 0);

	$sub = $attributes =~ m/sub:(\d+)/i ? $1 : 0;
	
	if ($est_end <= $est_start) {	# Need to recompute matches for this case
		my @est_seq = split(//, $est_sequence);
		my @gen_seq = split(//, $genomic_sequence);
		for (my $i=$est_start; $i <= $est_end; $i++) {
			$matches++ if ($est_seq[$i - 1] eq $gen_seq[$i - 1]);
		} # end of for loop
	} # end of if statement
	else {
		$matches = $est_end - $est_start + 1 - $sub;
	} # end of else statement
	
#	if ($est_start <= $est_end) {
#		my $gen_sub_sequence = substr($genomic_sequence, $est_start - 1, $est_end - $est_start - 1);
#		$sub = $gen_sub_sequence =~ tr/a-z//;	# Quick way to compute lowecase letters (substitutions)
#		$matches = $est_end - $est_start + 1 - $sub;
#	} # End of of if statement

	# Determine the type of the gap from the attributes
	if ($attributes =~ m/^(\S+):(\d+\.?\d*)\.\.(term|donor|acceptor|ins|del|end):(\d+\.?\d*)/) {
		my $type = $3;
		my $val = $4;
		if ($type =~ m/^(acceptor|donor)$/) {	# Its splicing gap, get splice distance
			if ($attributes =~ m/.*,splice_dist(_\d+)?:(\d+)/i) {	# Obtain the very last splice distance from attributes string
				$splice = $2;
			} # end of if statement
		} # end of if statement
		elsif ($type =~ m/^ins$/) {	# Insertion
			$ins += $val;
		} # end of else statement
		elsif ($type =~ m/^del$/) {	# Deletion
			$del += $val;
		} # end of else if statemetn
	} # end of if statement
	else {
		print STDERR sprintf("\n");
		print STDERR sprintf("     ERROR: CANNOT DETERMINE THE TYPE OF GAP FROM THE ALIGNMENT FOR\n");
		print STDERR sprintf("            READ '%s' : %s\n", $name, $attributes);
		print STDERR sprintf("\n");
		exit();
	} # end of else statement

	return ($matches, $sub, $ins, $del, $n_count, $splice);
} # end of sub getPolymorphisms

# Gets a single or paired end record from the open file handle
sub getGSNAPRecords {
	my ($fh) = @_;
	my (%mate1, %mate2, $ptr, $paths_num);
	my ($name, $seq, $qual, $type);
	my $stop = false;

	while (!$stop && !eof($fh)) {
		my $filepos = tell($fh);			# Get current file position
		my $line = <$fh>;	chomp($line);	# Get current line
	
		if (length($line) != 0) {
			if ($line =~ m/^>/) {	# Start of mate 1 or start of next record
				if (scalar(keys %mate1) > 0) {	# Must be start of next record
					seek($fh, $filepos, 0);		# Reposition cursor to the beginning of the line
					$stop = true;				# Stop reading
				} # end of if statement

				if (!$stop) {	# Process this line
					my @fields = split(/\t/, $');
					
					$seq = &trim($fields[0]);	# Get sequence information
					$type = &trim($fields[1]);		# Get alignment count or type
				
					if (scalar(@fields) == 4) {	# Read line with quality values introduced in GSNAP 2011-03-11
						$name = &trim($fields[3]);
						$qual = &trim($fields[2]);
					} # end of if statement
					else {
						$name = &trim($fields[2]);
						$qual = "*";		# No quality
					} # end of else statement

					$ptr = \%mate1;
					$paths_num = 0;
				} # end of if statement
			} # End of if statement
			elsif ($line =~ m/^</) {	# Start of mate 2
				my @fields = split(/\t/, $');

				$seq = &trim($fields[0]);
				$type = &trim($fields[1]);

				if (scalar(@fields) == 4) {	# Read line with quality values instroduced in GSNAP 2011-03-11
					$name = &trim($fields[3]);
					$qual = &trim($fields[2]);
				} # end of if statemetn
				else {
					$name = &trim($fields[2]);
					$qual = "*";		# No quality
				} # End of else statement

				$ptr = \%mate2;
				$paths_num = 0;
			} # end of else if statement
			elsif ($line =~ m/^(\s|,)/i) {
				my ($alignment, $est_coords, $genomic_coords, $attributes, $scores, $fragment_attributes) = split(/\t/, $line);
				my ($est_start, $est_end) = &getESTCoords($name, $est_coords);
				my ($matches, $sub, $ins, $del, $n_count, $splice) = &getPolymorphisms($name, $est_start, $est_end, $seq, substr($alignment, 1), $attributes);
				my ($strand, $genomic, $gen_start, $gen_end) = &getGenomicCoords($name, $genomic_coords);
				my ($translocation_inversion_scramble) = &isSpliceTranslocationInversionScramble($name, $attributes);

				if ($alignment =~ m/^\s/) {	# Start new path
					$paths_num++;	# Increment

					$ptr->{$paths_num}->{"NAME"} = $name;
					$ptr->{$paths_num}->{"SEQUENCE"} = $seq;
					$ptr->{$paths_num}->{"SEQUENCE_LENGTH"} = length($seq);
					$ptr->{$paths_num}->{"QUALITY"} = $qual;
					$ptr->{$paths_num}->{"TYPE"} = $type;
					$ptr->{$paths_num}->{"PIECES"} = 1;
					$ptr->{$paths_num}->{"ATTRIBUTES"} = $attributes;
					$ptr->{$paths_num}->{"GENOMIC"} = $genomic;
					$ptr->{$paths_num}->{"STRAND"} = $strand;
					$ptr->{$paths_num}->{"GENOMIC_COORDS"} = sprintf("%s..%s", $gen_start, $gen_end);
					$ptr->{$paths_num}->{"GENOMIC_SEQUENCES"} = substr($alignment, 1);
					$ptr->{$paths_num}->{"EST_COORDS"} = $est_coords;
					$ptr->{$paths_num}->{"EST_TAIL_FRONT"} = $est_start - 1;
					$ptr->{$paths_num}->{"EST_TAIL_END"} = length($seq) - $est_end;
					$ptr->{$paths_num}->{"MATCHES"} = $matches;
					$ptr->{$paths_num}->{"SUBSTITUTIONS"} = $sub;
					$ptr->{$paths_num}->{"INSERTIONS"} = $ins;
					$ptr->{$paths_num}->{"DELETIONS"} = $del;
					$ptr->{$paths_num}->{"N_COUNTS"} = $n_count;
					$ptr->{$paths_num}->{"SPLICE_DISTANCES"} = $splice;
					$ptr->{$paths_num}->{"MAPPING_QUALITY"} = &getMappingQuality($scores);
					$ptr->{$paths_num}->{"TRANSLOCATION_INVERSION_SCRAMBLE"} = $translocation_inversion_scramble;
					$ptr->{$paths_num}->{"INSERT_LENGTH"} = &getInsertLength($fragment_attributes) if (defined($fragment_attributes));
				} # end of else statement
				else {	# Update fields
					$ptr->{$paths_num}->{"PIECES"}++;
					$ptr->{$paths_num}->{"ATTRIBUTES"} .= sprintf(" %s", $attributes);
					$ptr->{$paths_num}->{"GENOMIC_COORDS"} .= sprintf(" %s..%s", $gen_start, $gen_end);
					$ptr->{$paths_num}->{"GENOMIC_SEQUENCES"} .= sprintf(" %s", substr($alignment, 1));
					$ptr->{$paths_num}->{"EST_COORDS"} .= sprintf(" %s", $est_coords);
					$ptr->{$paths_num}->{"EST_TAIL_END"} = length($seq) - $est_end; # Update end tail
					$ptr->{$paths_num}->{"MATCHES"} .= sprintf(" %s",  $matches);
					$ptr->{$paths_num}->{"SUBSTITUTIONS"} .= sprintf(" %s", $sub);
					$ptr->{$paths_num}->{"INSERTIONS"} .= sprintf(" %s", $ins);
					$ptr->{$paths_num}->{"DELETIONS"} .= sprintf(" %s", $del);
					$ptr->{$paths_num}->{"N_COUNTS"} .= sprintf(" %s", $n_count);
					$ptr->{$paths_num}->{"SPLICE_DISTANCES"} .= sprintf(" %s", $splice);

					# Compute splice junctions if previous piece has splicing
					my @distances = split(/\s/, $ptr->{$paths_num}->{"SPLICE_DISTANCES"});
					if ($distances[$#distances - 1] != 0) {
						my ($junction, $score) = &computeSpliceJunction($name, $ptr->{$paths_num}->{"GENOMIC_SEQUENCES"}, $ptr->{$paths_num}->{"ATTRIBUTES"}, $strand);
						
						if (defined($junction) && defined($score)) {
							if (!exists $ptr->{$paths_num}->{"SPLICE_JUNCTIONS"}) {
								$ptr->{$paths_num}->{"SPLICE_JUNCTIONS"} = $junction;
								$ptr->{$paths_num}->{"SPLICE_JUNCTION_SCORES"} = $score;
							} # end of if statement
							else {
								$ptr->{$paths_num}->{"SPLICE_JUNCTIONS"} .= sprintf(" %s", $junction);
								$ptr->{$paths_num}->{"SPLICE_JUNCTION_SCORES"} .= sprintf(" %s", $score);
							} # end of else statement
						} # end of if statement
					} # end of if statement
				} # End of else statement
			} # End of else if statement
		} # end of if statement
	} # end of while loop

	# Need to fix hidden insertions
	# Mate 1
	foreach my $index (keys %mate1) {
		my @est_coords = split(/\s/, $mate1{$index}->{"EST_COORDS"});
		my @ins = split(/\s/, $mate1{$index}->{"INSERTIONS"});
		my @matches = split(/\s/, $mate1{$index}->{"MATCHES"});
		my $weird = false;

		for (my $i=0; $i < scalar(@est_coords); $i++) {
			if ($i < scalar(@est_coords) - 1) {	# Check if there is a 'silent' insertion (2011.11.17)
				my ($curr_start, $curr_end) = split(/\.\./, $est_coords[$i]);
				my ($next_start, $next_end) = split(/\.\./, $est_coords[$i + 1]);
				my $hidden = $next_start - $curr_end - 1;

				if ($ins[$i] == 0 && $hidden > 0 && $curr_start < $curr_end) {	# Update
					$ins[$i] = $hidden;
				} # end of if statemetn
			
				$weird = true if ($curr_start == $curr_end);
			} # end of if statement
		} # End of for loop

		if ($weird) {	# Remove entry
			delete $mate1{$index};
		} # end of if statemnte
		else {		# Update
			# Update
			$mate1{$index}->{"MATCHES"} = join(" ", @matches);
			$mate1{$index}->{"INSERTIONS"} = join(" ", @ins);
		} # end of else statemnt
	} # end of for each statement

	# Mate 2
	foreach my $index (keys %mate2) {
		my @est_coords = split(/\s/, $mate2{$index}->{"EST_COORDS"});
		my @ins = split(/\s/, $mate2{$index}->{"INSERTIONS"});
		my @matches = split(/\s/, $mate2{$index}->{"MATCHES"});
		my $weird = false;

		for (my $i=0; $i < scalar(@est_coords); $i++) {
			if ($i < scalar(@est_coords) - 1) {	# Check if there is a 'silent' insertion (2011.11.17)
				my ($curr_start, $curr_end) = split(/\.\./, $est_coords[$i]);
				my ($next_start, $next_end) = split(/\.\./, $est_coords[$i + 1]);
				my $hidden = $next_start - $curr_end - 1;

				if ($ins[$i] == 0 && $hidden > 0 && $curr_start < $curr_end) {	# Update
					$ins[$i] = $hidden;
				} # end of if statemetn
			
				$weird = true if ($curr_start == $curr_end);
			} # end of if statement
		} # End of for loop

		if ($weird) {	# Remove entry
			delete $mate2{$index};
		} # end of if statemnte
		else {		# Update
			# Update
			$mate2{$index}->{"MATCHES"} = join(" ", @matches);
			$mate2{$index}->{"INSERTIONS"} = join(" ", @ins);
		} # end of else statemnt
	} # end of for each statement

#	if ($legacy) {	# Fix legacy parsing
#		foreach my $index (keys %mate1) {
#			if ($mate1{$index}->{"PIECES"} > 2) {
#				delete $mate1{$index};
#			} # end of if statement
#		} # end of for loop
#
#		foreach my $index (keys %mate2) {
#			if ($mate2{$index}->{"PIECES"} > 2) {
#				delete $mate2{$index};
#			} # end of if statement
#		} # end of for each statement
#	} # end of if statement

	return (\%mate1, \%mate2);
} # end of sub getGSNAPRecords

# Returns the total count of accumuated values
sub getTotalValue {
	my @tokens = split(/\s/, $_[0]);
	my $total = 0;
	
	foreach my $t (@tokens) {
		$total += $t;
	} # end of for each statement

	return $total;
} # End of sub getTotalValue

# Returns the maximum value from the accumulated values
sub getMaximumValue {
	my @tokens = split(/\s/, $_[0]);
	return &max(@tokens);
} # End of sub getMaximumValue

# From a list of values, returns a new list that contains only unique numbers
sub getUniqueValues {
	my @input = @_;
	my %keys;

	foreach my $i (@input) {
		$keys{$i} = true;
	} # end of for each statement

	return sort {$a <=> $b} keys %keys;
} # end of sub getUniqueValues

# Returns the computed IDP penalty for INDELs
sub getIDPPenalty {
	my ($idp, $insertions, $deletions) = @_;
	my $penalty = 0;

	my @ins = split(/\s/, $insertions);
	my @del = split(/\s/, $deletions);

	for (my $i=0; $i < scalar(@ins); $i++) {
		if ($ins[$i] != 0 || $del[$i] != 0) {
			$penalty += $idp;
		} # end of if statement
	} # end of for loop

	return $penalty;
} # end of sub getIDPPenalty

# Validates all available paths and returns the index of the best path by validating
# the total number of substitutions, insertions, deletions, and N count
sub getBestPath {
    my $mate = $_[0];
    my $best_path;
    my $best_score;

    foreach my $index (keys %{ $mate }) {
		my $score = &getTotalValue($mate->{$index}->{"SUBSTITUTIONS"}) + &getTotalValue($mate->{$index}->{"N_COUNTS"}) +
					&getTotalValue($mate->{$index}->{"INSERTIONS"}) + &getTotalValue($mate->{$index}->{"DELETIONS"});

		if (!defined($best_path) || $score < $best_score) {
			$best_path = $index;
			$best_score = $score;
		} # end of if statement
    } # end of for each statement

    return $best_path;
} # end of sub getBestPath

# Validate all available fragments and returns the index of the best path by validating
# the total number of substitutions, insertions, deletions, and N ocunt
sub getBestFragment {
    my ($mate1, $mate2, @pairs) = @_;
    my $best_fragment;
    my $best_score;

    foreach my $index (@pairs) {
        my $score = &getTotalValue($mate1->{$index}->{"SUBSTITUTIONS"}) + &getTotalValue($mate1->{$index}->{"N_COUNTS"}) +
                    &getTotalValue($mate1->{$index}->{"INSERTIONS"}) + &getTotalValue($mate1->{$index}->{"DELETIONS"}) +
                    &getTotalValue($mate2->{$index}->{"SUBSTITUTIONS"}) + &getTotalValue($mate2->{$index}->{"N_COUNTS"}) +
                    &getTotalValue($mate2->{$index}->{"INSERTIONS"}) + &getTotalValue($mate2->{$index}->{"DELETIONS"});

        if (!defined($best_fragment) || $score < $best_score) {
            $best_fragment = $index;
            $best_score = $score;
        } # end of if statement
    } # end of for each statement

    return $best_fragment;
} # end of sub getBestFragment

# Evaluate reads and returns the indexes of good paths
sub evaluateReads {
	my ($params, $mate) = @_;
	my @good_paths;

	my @mismatches = split(/ /, $params->{"mismatches"});
	my @tails = split(/ /, $params->{"tails"});
	my $idp = $params->{"idp"};
	my $max_splice = $params->{"max_splice"};

	foreach my $index (sort {$a <=> $b} keys %{ $mate }) {
		my $length = $mate->{$index}->{"SEQUENCE_LENGTH"};
		my $mis_allowed = scalar(@mismatches) == 1 ? $mismatches[0] : ceil( ($length * $mismatches[0])  / $mismatches[1]);
		my $tail_allowed = scalar(@tails) == 1 ? $tails[0] : ceil( ($length * $tails[0]) / $tails[1]);

		my $total_mismatches = &getTotalValue($mate->{$index}->{"SUBSTITUTIONS"}) +
		                       &getIDPPenalty($idp, $mate->{$index}->{"INSERTIONS"}, $mate->{$index}->{"DELETIONS"});
		my $total_tails = $mate->{$index}->{"EST_TAIL_FRONT"} + $mate->{$index}->{"EST_TAIL_END"};
		my $maximum_splice_distance = &getMaximumValue($mate->{$index}->{"SPLICE_DISTANCES"});

		if ($total_mismatches <= $mis_allowed && $maximum_splice_distance <= $max_splice &&
		    $mate->{$index}->{"TRANSLOCATION_INVERSION_SCRAMBLE"} == false) {

			if ($params->{"ignoretail"} || $total_tails <= $tail_allowed) {
				push(@good_paths, $index);
			} # end of if statement
		} # end of if statement
	} # end of for each statement

	return @good_paths;
} # end of sub evaluateReads

# Returns the indexes of correctly formed pairs
sub getPathPairs {
	my ($mate1, $mate2, @keys) = @_;
	@keys = &getUniqueValues(@keys);		# Remove duplicate indeces
	my @pairs;

	foreach my $k (@keys) {
		if (exists $mate1->{$k} && exists $mate2->{$k}) {
			push(@pairs, $k) if ($mate1->{$k}->{"TYPE"} =~ m/^\d+ concordant$/ && $mate2->{$k}->{"TYPE"} =~ m/^\d+ concordant$/);
		} # end of if statmenet
	} # end of for each statement

	return @pairs;
} # end of sub getPathPairs

# Returns the start and end coordinates from the list of parametric coordinates
sub getStartEndCoordinates {
	my ($name, $coords) = @_;
	my ($start, $end);

	foreach my $c (split(/\s/, $coords)) {
		if ($c =~ m/^(\d+)\.\.(\d+)$/) {
			if (!defined($start)) {
				$start = &min($1, $2);
				$end = &max($1, $2);
			} # end of if statement
			else {
				$start = &min($start, $1, $2);
				$end = &max($end, $1, $2);
			} # End of else statemetn
		} # end of if statement
		else {
			print STDERR sprintf("\n");
			print STDERR sprintf("     ERROR: CANNOT DETERMINE THE START AND END COORDINATES FOR\n");
			print STDERR sprintf("            READ '%s' : %s\n", $name, $coords);
			print STDERR sprintf("\n");
			exit();
		} # end of else statemetn
	} # end of for each statement

	return ($start, $end);
} # end of sub getStartEndCoordinates

# computes the splice junctions and scores
sub computeSpliceJunction {
    my ($name, $genomic, $attributes, $strand) = @_;
    my @gen = split(/\s/, $genomic);
    my @attr = split(/\s/, $attributes);

    my ($junction1, $score1);
    my ($junction2, $score2);

    # Obtain splice score for site #1
    if ($attr[$#attr - 1] =~ m/(donor|acceptor):(\d+\.\d+)/) {  # There is splcing score, continue
        if ($attr[$#attr - 1] =~ m/.*(donor|acceptor):(\d+\.\d+)/) { # obtain the LAST instance of donor/acceptor score from the attributes
            $score1 = $2;
        } # end of if statement
        else {
            print STDERR sprintf("\n");
            print STDERR sprintf("  ERROR: CANNOT DETERMINE SPLICE 1 SCORE (%s): %s\n", $name, $attr[$#attr - 1]);
            print STDERR sprintf("\n");
            exit();
        } # end of else statement

        # Compute junction
        if ($gen[$#gen - 1] =~ m/.*([a-z]{2})-*$/i) {   # obtain the LAST two lowercase letters from the genomic sequence
            $junction1 = uc($1);
        } # end of if statement
        else {
            print STDERR sprintf("\n");
            print STDERR sprintf("  ERROR: CANNOT DETERMINE SPLICE 1 JUNCTION (%s): %s\n", $name, $gen[$#gen - 1]);
            print STDERR sprintf("\n");
            exit();
        } # end of else if statement
    } # End of if statement

	    # obtain splice score for site #2
    if ($attr[$#attr] =~ m/(donor|acceptor):(\d+\.\d+)/) {  # There is splcing score, continue
        if ($attr[$#attr] =~ m/(donor|acceptor):(\d+\.\d+)/) {  # obtain the FIRST instance of donor/acceptor score from the attributes
            $score2 = $2;
        } # End of if statement
        else {
            print STDERR sprintf("\n");
            print STDERR sprintf("  ERROR: CANNOT DETERMINE SPLICE 2 SCORE (%s): %s\n", $name, $attr[$#attr]);
            print STDERR sprintf("\n");
            exit();
        } # end of else statement

        # Compute junction
        if ($gen[$#gen] =~ m/^-*([a-z]{2})/ || $gen[$#gen] =~ m/^-*\S+([a-z]{2})-*/) {  # Obtain the FIRST two lowercase letters from genomic sequence
            $junction2 = uc($1);
        } # End of if statement
        else {
            print STDERR sprintf("\n");
            print STDERR sprintf("  ERROR: CANNOT DETERMINE SPLICE 2 JUNCTION (%s): %s\n", $name, $gen[$#gen]);
            print STDERR sprintf("\n");
            exit();
        } # end of else if statement
    } # End of if statement

    my ($junction, $score);
    if (defined($score1) && defined($junction1) &&
        defined($score2) && defined($junction2)) {
        $junction = sprintf("%s-%s", $junction1, $junction2);
        $score = sprintf("%s,%s", $score1, $score2);
    } # end of if statement

    return ($junction, $score);
} # end of sub computeSpliceJunction

# Computes the cigar string for SAM output
sub computeCIGARString {
	my ($mate, $path_num) = @_;
	my @cigar;

	my $strand = $mate->{$path_num}->{"STRAND"};
	my $tail_front = $mate->{$path_num}->{"EST_TAIL_FRONT"};
	my $tail_end = $mate->{$path_num}->{"EST_TAIL_END"};
	my @est_coords = split(/\s/, $mate->{$path_num}->{"EST_COORDS"});
	my @matches = split(/\s/, $mate->{$path_num}->{"MATCHES"});
	my @sub = split(/\s/, $mate->{$path_num}->{"SUBSTITUTIONS"});
	my @ins = split(/\s/, $mate->{$path_num}->{"INSERTIONS"});
	my @del = split(/\s/, $mate->{$path_num}->{"DELETIONS"});
	my @splice = split(/\s/, $mate->{$path_num}->{"SPLICE_DISTANCES"});
	
	push(@cigar, sprintf("%sS", $tail_front)) if ($tail_front != 0);	# Add clipping left

	for (my $i=0; $i < scalar(@est_coords); $i++) {
		push(@cigar, sprintf("%sM", $sub[$i] + $matches[$i])) if ($sub[$i] + $matches[$i] > 0);
		push(@cigar, sprintf("%sN", $splice[$i])) if ($splice[$i] > 0);
		push(@cigar, sprintf("%sI", $ins[$i])) if ($ins[$i] > 0);
		push(@cigar, sprintf("%sD", $del[$i])) if ($del[$i] > 0);
	} # end of for loop

	push(@cigar, sprintf("%sS", $tail_end)) if ($tail_end != 0);		# Add clipping right

	my $str;
	if ($strand eq "-") {
		$str = join("", reverse(@cigar));
	} # end of if statemnet
	else {
		$str = join("", @cigar);
	} # end of else statement

	return $str;
} # end of sub computeCIGARString

# Computes the MD string for SAM output
sub computeMDString {
	my ($mate, $path_num) = @_;
	
	my @est_coords = split(/\s/, $mate->{$path_num}->{"EST_COORDS"});
	my @gen_coords = split(/\s/, $mate->{$path_num}->{"GENOMIC_COORDS"});
	my @est_nucleotides = split(//, uc($mate->{$path_num}->{"SEQUENCE"}));
	my @gen_sequences = split(/\s/, uc($mate->{$path_num}->{"GENOMIC_SEQUENCES"}));
	my $strand = $mate->{$path_num}->{"STRAND"};
	my $total_substitutions = &getTotalValue($mate->{$path_num}->{"SUBSTITUTIONS"});
	my $total_insertions = &getTotalValue($mate->{$path_num}->{"INSERTIONS"});
	my $total_deletions = &getTotalValue($mate->{$path_num}->{"DELETIONS"});
	my $total_n_counts = &getTotalValue($mate->{$path_num}->{"N_COUNTS"});
	my @del = split(/\s/, $mate->{$path_num}->{"DELETIONS"});
	my @mismatches;
	my $count = 0;
	my $matches = 0;

	if ($total_substitutions + $total_insertions + $total_deletions + $total_n_counts == 0) {	# Perfect
		$count = 0;
		push(@mismatches, $mate->{$path_num}->{"SEQUENCE_LENGTH"} - $mate->{$path_num}->{"EST_TAIL_FRONT"} - $mate->{$path_num}->{"EST_TAIL_END"});
	} # end of if statement
	else {
		for (my $i=0; $i < scalar(@est_coords); $i++) {
			my ($est_start, $est_end) = split(/\.\./, $est_coords[$i]);
			my ($gen_start, $gen_end) = split(/\.\./, $gen_coords[$i]);
			my @gen_nucleotides = split(//, $gen_sequences[$i]);
			my ($gen_pos, $gen_nt, $read_pos, $read_nt);

            for (my $offset=0; $offset < $est_end - $est_start + 1; $offset++) {
                my $read_nt = $est_nucleotides[$est_start + $offset - 1];
                my $gen_nt = $gen_nucleotides[$est_start + $offset - 1];

                # nucleotides are already in uppercase 
                if ($read_nt ne $gen_nt) {
                    if ($strand eq "-") {
                        unshift(@mismatches, $matches);
                    } # end of if statement
                    else {
                        push(@mismatches, $matches);
                    } # end of else statement

                    if ($strand eq "-") {
                        unshift(@mismatches, &reverseComplement($gen_nt));
                    } # end of if statment
                    else {
                        push(@mismatches, $gen_nt);
                    } # end of else statement
                    $matches = 0;
                    $count++;
                } # End of if statement
                else {
                    $matches++;
                } # end of else statemente
            } # end of for loop

            # print deletion
            if ($del[$i] > 0) {
                if ($strand eq "-") {
                    unshift(@mismatches, $matches);
                } # end of if statement
                else {
                    push(@mismatches, $matches);
                } # end of else statement

                my $delseq = "";
                for (my $j=0; $j < $del[$i]; $j++) {
					my $index = $j + $est_end;
					$delseq .= $gen_nucleotides[$j + $est_end];
                } # end of for loop

                if ($strand eq "-") {
                    unshift(@mismatches, sprintf("^%s", &reverseComplement($delseq)));
                } # end of if statement
                else {
                    push(@mismatches, sprintf("^%s", $delseq));
                } # end of else statement

                $matches = 0;
            } # end of if statemnt
		} # end of for loop

		# Very last piece
        if ($strand eq "-") {
           	unshift(@mismatches, $matches);
        } # end of if statement
        else {
           	push(@mismatches, $matches);
        } # End of else statemetn
	} # end of else statament

	return ($count + $total_insertions + $total_deletions, join("", @mismatches));
} # End of sub computeMDString

# Computes the XS and XT tags for SAM output using the splice junction dinucleotides and genome orientation
# Flips the splice junction accordingly relative to the reference genome and returns
sub computeXS_XTString {
    my ($strand, $junctions, $scores) = @_;
    my %possible_xs;
    my @possible_xt;
    my $overall_xs;

    my @j = split(/\s/, $junctions);
    my @s = split(/\s/, $scores);

    for (my $i=0; $i < scalar(@j); $i++) {
        my ($xt, $xs);

        if ($strand eq "+") {
            $xt = $j[$i];
            push(@possible_xt, sprintf("%s,%s", $xt, $s[$i]));
        } # end of if statement
        else {
            $xt = &reverseComplement($j[$i]);
            my @tmp = split(/,/, $s[$i]);   # Need to reverse scores accordingly
            unshift(@possible_xt, sprintf("%s,%s,%s", $xt, $tmp[1], $tmp[0]));
        } # end of else statement

        if ($xt =~ "GT-AG" || $xt =~ "GC-AG" || $xt =~ "AT-AC") {
            $xs = "+";
        } # end of if statement
        elsif ($xt =~ "CT-AC" || $xt =~ "CT-GC" || $xt =~ "GT-AT") {
            $xs = "-";
        } # end of else if statmenet
        else {
            $xs = "?";
        } # End of else statement

        $possible_xs{$xs} = 1;
    } # end of for loop

    my @tmp = keys %possible_xs;
    if (scalar(@tmp) == 1) {
        $overall_xs = shift(@tmp);
    } # end of if statmenet
    else {
        $overall_xs = "?";
    } # end of else statmenet

    return ($overall_xs, join(";", @possible_xt));
} # end of sub computeXS_XTString

# prints the GFF3 header to output handler
sub printGFF3Header {
    my ($params, $ofh) = @_;

    my @input = split(/\t/, $params->{"input"});
	my $mis = $params->{"mismatches"};
    my @mismatches = split(/ /, $mis);
    my $idp = $params->{"idp"};
    my $best = $params->{"best"};
    my $unique = $params->{"unique"};
    my @max_tail = split(/ /, $params->{"tails"});
    my $ignoretail = $params->{"ignoretail"};
    my $max_splice = $params->{"max_splice"};
	my $processors = $params->{"processors"};
#	my $legacy = $params->{"legacy"};

    print $ofh sprintf("##gff3-version\t3\n");
    print $ofh sprintf("# %s\n", scalar(localtime(time)));
    print $ofh sprintf("#\n");
    print $ofh sprintf("# Script: %s\n", $0);
    print $ofh sprintf("# Script version: %s\n", VERSION);
    print $ofh sprintf("#\n");

    if (scalar(@mismatches) == 1) {
        print $ofh sprintf("# Uniform mismatches allowed per read: %s (regardless of read length)\n", $mismatches[0]);
    } # End of if statement
    else {
        print $ofh sprintf("# Non-Uniform mismatches allowed per read: %s %s (allow at most %s mismatches per every %s bp)\n",
                            $mismatches[0], $mismatches[1], $mismatches[0], $mismatches[1]);
    } # End of else statemnet

    print $ofh sprintf("# INDEL Penalty: %d\n",$idp);

    if ($ignoretail) {
        print $ofh sprintf("# Ignore tails: Yes\n");
    } # End of if statemnet
    else {
        if (scalar(@max_tail) == 1) {
            print $ofh sprintf("# Maximum uniform tails allowed: %s (front tail + end tail)\n", $max_tail[0]);
        } # end of if statement
        else {
            print $ofh sprintf("# Maximum variable tails allowed: %s %s (front tail + end tail, allow %d bases as tails per every %s bp)\n",
                               $max_tail[0], $max_tail[1], $max_tail[0], $max_tail[1]);
        } # end of if statement
    } # End of else statement

    print $ofh sprintf("# Maximum splice distance allowed: %s\n", $max_splice);
    print $ofh sprintf("# Parse all possible aligments: %s\n", !$best && !$unique ? "Yes" : "No");
    print $ofh sprintf("# Best alignment parsing: %s\n", $best ? "Yes" : "No");
    print $ofh sprintf("# Unique aligment parsing: %s\n", $unique ? "Yes" : "No");
    print $ofh sprintf("# Processors: %s\n", $processors);
#	print $ofh sprintf("# Legacy Output Support: %s\n", $legacy ? "Yes" : "No");
	print $ofh sprintf("#\n");
	print $ofh sprintf("# GSNAP Input Files (%s)\n", scalar(@input));
	
    foreach my $f (@input) {
        print $ofh sprintf("#     - %s\n", $f);
    } # end of for each statement

	print $ofh sprintf("#\n");
} # End of printGFF3Header

# prints the SAM header to the output handler
sub printSAMHeader {
    my ($params, $ofh) = @_;
    
    my $mis = $params->{"mismatches"};
    my @mismatches = split(/ /, $mis);
    my $idp = $params->{"idp"};
    my $best = $params->{"best"};
    my $unique = $params->{"unique"};
    my @max_tail = split(/ /, $params->{"tails"});
    my $ignoretail = $params->{"ignoretail"};
    my $max_splice = $params->{"max_splice"};
    my $lengthFile = $params->{"lengthFile"};

    my $fh = new FileHandle();
    open ($fh, $lengthFile) or die("Cannot open length file\n");

    print $ofh sprintf("\@HD\tVN:1.0\tSO:unsorted\n");
    print $ofh sprintf("\@PG\tID:GSNAP\n");

    while (<$fh>) {
        chomp;
        my @fields = split(/\t/, $_); 
     
        if (scalar(@fields) != 2 || $fields[1] !~ m/^(\d+)$/) {
            print STDERR sprintf("\n");
            print STDERR sprintf("INVALID REFERENCE LENGTH FILE:\n");
            print STDERR sprintf("   Reference length file is a plain tab-delimited file in which the first column\n");
            print STDERR sprintf("   is the reference identifier and the second column is the length of the reference in\n");
            print STDERR sprintf("   in base pairs.\n");
            print STDERR sprintf("\n");
            exit();
        } # End of if statement
        else {
            print $ofh sprintf("\@SQ\tSN:%s\tLN:%s\n", $fields[0], $fields[1]);
        } # end of else statement
    } # End of while loop
    close ($fh);
} # end of sub printSAMHeader

# Prints the specified fragment in GFF3 format
sub printFragmentGFF3 {
	my ($ofh, $path_num, $mate1, $mate2, $fragment_id, $source) = @_;

	my $name1 = $mate1->{$path_num}->{"NAME"};	$name1 .= "/1" if ($name1 !~ m/^\/(1|2)$/);
	my $genomic1 = $mate1->{$path_num}->{"GENOMIC"};
	my ($gen_start1, $gen_end1) = &getStartEndCoordinates($name1, $mate1->{$path_num}->{"GENOMIC_COORDS"});
	my $insert_length1 = $mate1->{$path_num}->{"INSERT_LENGTH"};
	my $tail1 = $mate1->{$path_num}->{"EST_TAIL_FRONT"} + $mate1->{$path_num}->{"EST_TAIL_END"};
	my $sub1 = &getTotalValue($mate1->{$path_num}->{"SUBSTITUTIONS"});
	my $ins1 = &getTotalValue($mate1->{$path_num}->{"INSERTIONS"});
	my $del1 = &getTotalValue($mate1->{$path_num}->{"DELETIONS"});

	my $name2 = $mate2->{$path_num}->{"NAME"};	$name2 .= "/2" if ($name2 !~ m/^\/(1|2)$/);
	my $genomic2 = $mate2->{$path_num}->{"GENOMIC"};
	my ($gen_start2, $gen_end2) = &getStartEndCoordinates($name2, $mate2->{$path_num}->{"GENOMIC_COORDS"});
	my $insert_length2 = $mate2->{$path_num}->{"INSERT_LENGTH"};
	my $tail2 = $mate2->{$path_num}->{"EST_TAIL_FRONT"} + $mate2->{$path_num}->{"EST_TAIL_END"};
	my $sub2 = &getTotalValue($mate2->{$path_num}->{"SUBSTITUTIONS"});
	my $ins2 = &getTotalValue($mate2->{$path_num}->{"INSERTIONS"});
	my $del2 = &getTotalValue($mate2->{$path_num}->{"DELETIONS"});

	my ($name, $genomic, $ins_length);
	if ($name1 =~ m/^(\S+)\/(\d+)$/) {
		$name = $1;
		$genomic = $genomic1;
		$ins_length = $insert_length1;
	} # end of if statement
	else {
		die("Invalid mate name: $name1\n");
	} # end of else statement

    print $ofh sprintf("%s\t%s\tfragment\t%s\t%s\t.\t%s\t.\tID=%s;Name=%s;Note=Insert Length: %d bp, Polymorphisms: %d (sub=%d, ins=%d, del=%d, tail=%d)\n",
                       $genomic, $source, &min($gen_start1, $gen_end1, $gen_start2, $gen_end2), 
					   &max($gen_start1, $gen_end1, $gen_start2, $gen_end2),
                       ".", $fragment_id, $name, $ins_length, 
                       $sub1 + $ins1 + $del1 + $tail1 + $sub2 + $ins2 + $del2 + $tail2,
                       $sub1 + $sub2, $ins1 + $ins2, $del1 + $del2, $tail1 + $tail2);
	
	if ($gen_start1 < $gen_start2) {	# Print mate 1 and then mate 2
        my $match_id = sprintf("%s_%s", $fragment_id, 1);
        &printReadGFF3($ofh, $path_num, $mate1, 1, $source, $match_id, $fragment_id);
     
        $match_id = sprintf("%s_%s", $fragment_id, 2);
        &printReadGFF3($ofh, $path_num, $mate2, 2, $source, $match_id, $fragment_id);
    } # End of if statemnet
    else {  # Print mate 2 and then mate 1
        my $match_id = sprintf("%s_%s", $fragment_id, 2);
        &printReadGFF3($ofh, $path_num, $mate2, 2, $source, $match_id, $fragment_id);

        $match_id = sprintf("%s_%s", $fragment_id, 1);
        &printReadGFF3($ofh, $path_num, $mate1, 1, $source, $match_id, $fragment_id);
    } # end of else statement
} # end of sub printFragmentGFF3

# Prints the specified fragment in SAM format
sub printFragmentSAM {
	my ($ofh, $path_num, $mate1, $mate2, $index) = @_;
	my ($name, $sequence, $quality, $insert_length, $mapq);
	my ($genomic, $strand, $gen_start1, $gen_end1, $gen_start2, $gen_end2);
	my ($flag, $cigar, $count, $mdstring);

	# Only compute once
	($gen_start1, $gen_end1) = &getStartEndCoordinates($mate1->{$path_num}->{"NAME"}, $mate1->{$path_num}->{"GENOMIC_COORDS"});
	($gen_start2, $gen_end2) = &getStartEndCoordinates($mate2->{$path_num}->{"NAME"}, $mate2->{$path_num}->{"GENOMIC_COORDS"});

	# mate 1
	$name = $mate1->{$path_num}->{"NAME"};
	$sequence = $mate1->{$path_num}->{"SEQUENCE"};
	$quality = $mate1->{$path_num}->{"QUALITY"};
	$insert_length = $mate1->{$path_num}->{"INSERT_LENGTH"};
	$mapq = $mate1->{$path_num}->{"MAPPING_QUALITY"};
	$genomic = $mate1->{$path_num}->{"GENOMIC"};
	$strand = $mate1->{$path_num}->{"STRAND"};

	if ($strand eq "-") {	# Reverse
		$sequence = &reverseComplement($sequence);
		$quality = join("", reverse(split(//, $quality)));
	} # End of if statement

    $flag = 0;                                  # reset
    $flag += 0x1;                               # 0x1 (or decimal 1) for multiple fragments in sequencing
    $flag += 0x2;                               # 0x2 (or decimal 2) for proper alignment
    $flag += $strand eq "-" ? 0x10 : 0x20;      # if strand is reverse, add 0x10 (or decimal 16) otherwise add 0x20 (or decimal 32)
    $flag += 0x40;                              # 0x40 (or decimal 64) for first mate
    $flag += 0x100 if ($index != 0);            # index != 0 means secondary alignment and add 0x100 (or decimal 256)

	print $ofh sprintf("%s\t%s\t%s\t", $name, $flag, $genomic);
	print $ofh sprintf("%s\t%s\t", $gen_start1, $mapq);

	$cigar = &computeCIGARString($mate1, $path_num);

	print $ofh sprintf("%s\t%s\t%s\t%s\t", $cigar, "=", $gen_start2, $gen_start1 > $gen_start2 ? $insert_length * -1 : $insert_length);
	print $ofh sprintf("%s\t%s\tPG:Z:GSNAP\t", $sequence, $quality);

	($count, $mdstring) = &computeMDString($mate1, $path_num);
	print $ofh sprintf("NM:i:%d\tMD:Z:%s", $count, $mdstring);

    if (exists $mate1->{$path_num}->{"SPLICE_JUNCTIONS"}) {    # Need to print splice information
        # Using the strand information, compute the appropriate splice junction dinucleotides
        my ($xs, $xt) = &computeXS_XTString($strand, $mate1->{$path_num}->{"SPLICE_JUNCTIONS"}, $mate1->{$path_num}->{"SPLICE_JUNCTION_SCORES"});
        print $ofh sprintf("\tXS:A:%s\tXT:Z:%s\n", $xs, $xt);
    } # end of if statemnet
    else {
        print $ofh sprintf("\n");
    } # end of else statement	

	# mate 2
	$name = $mate2->{$path_num}->{"NAME"};
	$sequence = $mate2->{$path_num}->{"SEQUENCE"};
	$quality = $mate2->{$path_num}->{"QUALITY"};
	$insert_length = $mate2->{$path_num}->{"INSERT_LENGTH"};
	$mapq = $mate2->{$path_num}->{"MAPPING_QUALITY"};
	$genomic = $mate2->{$path_num}->{"GENOMIC"};
	$strand = $mate2->{$path_num}->{"STRAND"};

	if ($strand eq "-") {	# Reverse
		$sequence = &reverseComplement($sequence);
		$quality = join("", reverse(split(//, $quality)));
	} # End of if statement

    $flag = 0;                                  # reset
    $flag += 0x1;                               # 0x1 (or decimal 1) for multiple fragments in sequencing
    $flag += 0x2;                               # 0x2 (or decimal 2) for proper alignment
    $flag += $strand eq "-" ? 0x10 : 0x20;      # if strand is reverse, add 0x10 (or decimal 16) otherwise add 0x20 (or decimal 32)
    $flag += 0x80;                              # 0x80 (or decimal 128) for second mate (last mate)
    $flag += 0x100 if ($index != 0);            # index != 0 means secondary alignment and add 0x100 (or decimal 256)

	print $ofh sprintf("%s\t%s\t%s\t", $name, $flag, $genomic);
	print $ofh sprintf("%s\t%s\t", $gen_start2, $mapq);

	$cigar = &computeCIGARString($mate2, $path_num);

	print $ofh sprintf("%s\t%s\t%s\t%s\t", $cigar, "=", $gen_start1, $gen_start2 > $gen_start1 ? $insert_length * -1 : $insert_length);
	print $ofh sprintf("%s\t%s\tPG:Z:GSNAP\t", $sequence, $quality);

	($count, $mdstring) = &computeMDString($mate2, $path_num);
	print $ofh sprintf("NM:i:%d\tMD:Z:%s", $count, $mdstring);

    if (exists $mate2->{$path_num}->{"SPLICE_JUNCTIONS"}) {    # Need to print splice information
        # Using the strand information, compute the appropriate splice junction dinucleotides
        my ($xs, $xt) = &computeXS_XTString($strand, $mate2->{$path_num}->{"SPLICE_JUNCTIONS"}, $mate2->{$path_num}->{"SPLICE_JUNCTION_SCORES"});
        print $ofh sprintf("\tXS:A:%s\tXT:Z:%s\n", $xs, $xt);
    } # end of if statemnet
    else {
        print $ofh sprintf("\n");
    } # end of else statement	
} # end of sub printFragmentSAM

# Prints the specified path in GFF3 format
sub printReadGFF3 {
	my ($ofh, $path_num, $mate, $mate_num, $source, $match_id, $fragment_id) = @_;

	my $name = $mate->{$path_num}->{"NAME"};	$name .= sprintf("/%s", $mate_num) if ($name !~ m/\/(1|2)$/);
	my $length = $mate->{$path_num}->{"SEQUENCE_LENGTH"};
	my $strand = $mate->{$path_num}->{"STRAND"};
	my $genomic = $mate->{$path_num}->{"GENOMIC"};
	my ($gen_start, $gen_end) = &getStartEndCoordinates($name, $mate->{$path_num}->{"GENOMIC_COORDS"});
	my @est_coords = split(/\s/, $mate->{$path_num}->{"EST_COORDS"});
	my @gen_coords = split(/\s/, $mate->{$path_num}->{"GENOMIC_COORDS"});
	my $tail = $mate->{$path_num}->{"EST_TAIL_FRONT"} + $mate->{$path_num}->{"EST_TAIL_END"};
	my $sub = &getTotalValue($mate->{$path_num}->{"SUBSTITUTIONS"});
	my $ins = &getTotalValue($mate->{$path_num}->{"INSERTIONS"});
	my $del = &getTotalValue($mate->{$path_num}->{"DELETIONS"});

	if ($strand eq "-") {	# Reverse
		@est_coords = reverse(@est_coords);
		@gen_coords = reverse(@gen_coords);
	} # end of if statement

    if (defined($fragment_id)) {
        print $ofh sprintf("%s\t%s\tmatch\t%s\t%s\t.\t%s\t.\tID=%s;Parent=%s;Name=%s;Note=Read Length: %d bp, Polymorphisms: %d (sub=%d, ins=%d, del=%d, tail=%d)\n",
                           $genomic, $source, $gen_start, $gen_end,
                           $strand, $match_id, $fragment_id, $name, $length,
						   $sub + $ins + $del + $tail, $sub, $ins, $del, $tail);
    } # end of if statemnet
    else {
        print $ofh sprintf("%s\t%s\tmatch\t%s\t%s\t.\t%s\t.\tID=%s;Name=%s;Note=Read Length: %d bp, Polymorphisms: %d (sub=%d, ins=%d, del=%d, tail=%d)\n",
                           $genomic, $source, $gen_start, $gen_end,
                           $strand, $match_id, $name, $length,
						   $sub + $ins + $del + $tail, $sub, $ins, $del, $tail);
    } # End of else statement

	for (my $i=0; $i < scalar(@est_coords); $i++) {
		my ($e_start, $e_end) = &getStartEndCoordinates($name, $est_coords[$i]);
		my ($g_start, $g_end) = &getStartEndCoordinates($name, $gen_coords[$i]);

        print $ofh sprintf("%s\t%s\tHSP\t%s\t%s\t.\t%s\t.\tParent=%s;Target=%s %d %d\n",
                           $genomic, $source, $g_start, $g_end,
                           $strand, $match_id, $name, $e_start, $e_end);
    } # end of for loop
} # end of sub printReadGFF3

# Prints the specified read in SAM format
sub printReadSAM {
	my ($ofh, $path_num, $mate, $num) = @_;
	my ($name, $sequence, $quality, $insert_length, $mapq);
	my ($genomic, $strand, $gen_start, $gen_end);

	# Only compute once
	($gen_start, $gen_end) = &getStartEndCoordinates($mate->{$path_num}->{"NAME"}, $mate->{$path_num}->{"GENOMIC_COORDS"});

	$name = $mate->{$path_num}->{"NAME"};
	
	# Add /1 or /2 at the end of the name if specified
	if (defined($num) && $name !~ m/\/(1|2)$/) {
		$name .= "/" . $num;
	} # end of if statement

	$sequence = $mate->{$path_num}->{"SEQUENCE"};
	$quality = $mate->{$path_num}->{"QUALITY"};
	$insert_length = $mate->{$path_num}->{"INSERT_LENGTH"};
	$mapq = $mate->{$path_num}->{"MAPPING_QUALITY"};
	$genomic = $mate->{$path_num}->{"GENOMIC"};
	$strand = $mate->{$path_num}->{"STRAND"};

	my $flag = 0;		# Reset
	if ($strand eq "-") {	# Reverse
		$sequence = &reverseComplement($sequence);
		$quality = join("", reverse(split(//, $quality)));
		$flag += 0x10;		# Add 0x10 (or decimal 16) when strand opposite than the referene genome
	} # End of if statement

    print $ofh sprintf("%s\t%s\t%s\t", $name, $flag, $genomic);
    print $ofh sprintf("%s\t%s\t", $gen_start, $mapq);

    # Crreate cigar string
    my $cigar = &computeCIGARString($mate, $path_num);

    print $ofh sprintf("%s\t*\t0\t0\t", $cigar);
    print $ofh sprintf("%s\t%s\tPG:Z:GSNAP\t", $sequence, $quality);

    my ($count, $mdstring) = &computeMDString($mate, $path_num);
    print $ofh sprintf("NM:i:%d\tMD:Z:%s", $count, $mdstring);

    if (exists $mate->{$path_num}->{"SPLICE_JUNCTIONS"}) {    # Need to print splice information
        # Using the strand information, compute the appropriate splice junction dinucleotides
        my ($xs, $xt) = &computeXS_XTString($strand, $mate->{$path_num}->{"SPLICE_JUNCTIONS"}, $mate->{$path_num}->{"SPLICE_JUNCTION_SCORES"});
        print $ofh sprintf("\tXS:A:%s\tXT:Z:%s\n", $xs, $xt);
    } # end of if statemnet
    else {
        print $ofh sprintf("\n");
    } # end of else statement	
} # end of sub printReadSAM

# Merges temporary GFF3 output files and removes the temporary file from disk
sub mergeTempGFF3Output {
	my ($ofh, @files) = @_;
	my $fragment_id = 0;
	my $match_id = 0;

	foreach my $f (@files) {
		my $fh = new FileHandle();
		open ($fh, $f) or die("Cannot open temporary GFF3 output file $f\n");
		
		while (<$fh>) {
			chomp;
			my @fields = split(/\t/, $_);
			if ($fields[$#fields] =~ m/(ID=|Parent=)(PE_\d+)/) {    # Must be a fragment
				my $old = $2;
				my $new = $fields[2] =~ m/^fragment$/ ? sprintf("PE_%s", ++$fragment_id) : sprintf("PE_%s", $fragment_id);
				$fields[$#fields] =~ s/\Q$old\E/\Q$new\E/g;
				print $ofh sprintf("%s\n", join("\t", @fields));
			} # end of if statement
			elsif ($fields[$#fields] =~ m/(ID=|Parent=)(SE_\d+)/) { # Must be singleton
				my $old = $2;
				my $new = $fields[2] =~ m/^match$/ ? sprintf("SE_%s", ++$match_id) : sprintf("SE_%s", $match_id);
				$fields[$#fields] =~ s/\Q$old\E/\Q$new\E/g;
				print $ofh sprintf("%s\n", join("\t", @fields));
			} # end of else if statement
			else {  # Must be a singleton
				die("Cannot determine if entry is fragment or singleton:\n$_\n");
			} # end of else statement
		} # end of while loop
		close ($fh);
		unlink($f);	# Remove temporary file
	} # End of for each statement
} # end of sub mergeTempGFF3Output

# Merges temporary SAM output files and removes the temporary file from disk
sub mergeTempSAMOutput {
	my ($ofh, @files) = @_;

	foreach my $f (@files) {
		my $fh = new FileHandle();
		open ($fh, $f) or die("Cannot open temporary SAM output file $f\n");
		while (<$fh>) {
			chomp;
			if (length($_) != 0 && $_ !~ m/^@(HD|PG|SQ)/) {
				print $ofh sprintf("%s\n", $_);
			} # end of if statement
		} # end of while loop
		close ($fh);
		unlink($f);	# Remove temporary file
	} # end of for each statement
} # end of sub mergeOutputSAM

# Parse GSNAP
sub parseGSNAP {
	my ($params, $input, $ofh, $fragment_id, $match_id) = @_;

	my $format = $params->{"format"};		# Get output format
	my $best = $params->{"best"};
	my $unique = $params->{"unique"};
	my $source = $params->{"source"};
#	my $legacy = $params->{"legacy"};

	my ($paired_alignments, $paired_unique_alignments, $paired_best_alignments) = (0, 0, 0);
	my ($single_alignments, $single_unique_alignments, $single_best_alignments) = (0, 0, 0);

	my $fh = new FileHandle();
	open ($fh, $input) or die("Cannot open input file $input\n");

	my ($mate1, @good_paths1, $mate2, @good_paths2);
	while (!eof($fh)) {
		($mate1, $mate2) = &getGSNAPRecords($fh);

		if (defined($mate1)) {	# Process mate 1
			@good_paths1 = &evaluateReads($params, $mate1);
		} # end of if statement
		else {
			@good_paths1 = ();	# Reset
		} # end of if statement

		if (defined($mate2)) {	# Process mate 2
			@good_paths2 = &evaluateReads($params, $mate2);
		} # end of if statement
		else {
			@good_paths2 = ();	# Reset
		} # End of else statement

		my $asFragment = false;	# Controls if the reads should or should not be evaluated as fragments

		if (scalar(@good_paths1) > 0 && scalar(@good_paths2) > 0) {	# This is a potential fragment
			my @pairs = &getPathPairs($mate1, $mate2, @good_paths1, @good_paths2);

			if (scalar(@pairs) > 0) {	# Good Fragments were found, proceed to print
				$asFragment = true;
				$paired_alignments++;	# Increment paired alignments

				if (!$best && !$unique) {	# Print all possible paths
					if ($format =~ m/^sam$/i) {	# Print sam output
						for (my $i=0; $i < scalar(@pairs); $i++) {
							&printFragmentSAM($ofh, $pairs[$i], $mate1, $mate2, $i);
						} # end of for loop
					} # end of if statmeent
					else {	# Print gff3 output
						for (my $i=0; $i < scalar(@pairs); $i++) {
							&printFragmentGFF3($ofh, $pairs[$i], $mate1, $mate2, sprintf("PE_%s", ++$fragment_id), $source);		
						} # end of for loop
					} # End of else statement
				} # End of if statement
				elsif ($best && !$unique) {	# Print only the best possible alignment
					my $best_fragment = &getBestFragment($mate1, $mate2, @pairs);
					if (defined($best_fragment)) {
						$paired_best_alignments++;

						if ($format =~ m/^sam$/i) {
							&printFragmentSAM($ofh, $best_fragment, $mate1, $mate2, 0);
						} # end of if statement
						else {
							&printFragmentGFF3($ofh, $best_fragment, $mate1, $mate2, sprintf("PE_%s", ++$fragment_id), $source);
						} # end of else statement
					} # end of if statement
				} # end of else if statement
				elsif (!$best && $unique && scalar(@pairs) == 1) {	# Print only unique alignment
					$paired_unique_alignments++;	# Increment unique alignments
					if ($format =~ m/^sam$/i) {
						&printFragmentSAM($ofh, $pairs[0], $mate1, $mate2, 0);
					} # end of if statement
					else {
						&printFragmentGFF3($ofh, $pairs[0], $mate1, $mate2, sprintf("PE_%s", ++$fragment_id), $source);
					} # End of else statement
				} # end of else if statement
			} # end of if statement
		} # end of if statement
		
		if (!$asFragment && scalar(@good_paths1) > 0) {	# Need to print mate 1 as singleton
			$single_alignments++;	# Increment singletons count

			if (!$best && !$unique) {	# Print all possible paths
				if ($format =~ m/^sam$/i) {	# Print sam output
					for (my $i=0; $i < scalar(@good_paths1); $i++) {
						&printReadSAM($ofh, $good_paths1[$i], $mate1, 1);
					} # end of for loop
				} # end of if statmeent
				else {	# Print gff3 output
					for (my $i=0; $i < scalar(@good_paths1); $i++) {
						&printReadGFF3($ofh, $good_paths1[$i], $mate1, 1, $source, sprintf("SE_%s", ++$match_id));
					} # end of for loop
				} # End of else statement
			} # End of if statement
			elsif ($best && !$unique) {	# Print only the best possibel alignment
				my $best_path = &getBestPath($mate1);

				if (defined($best_path)) {
					$single_best_alignments++;

					if ($format =~ m/^sam$/i) {
						&printReadSAM($ofh, $best_path, $mate1, 1);
					} # end of if statement
					else {
						&printReadGFF3($ofh, $best_path, $mate1, 1, $source, sprintf("SE_%s", ++$match_id));
					} # End of else statement
				} # end of if statement
			} # end of else if statement
			elsif (!$best && $unique && scalar(@good_paths1) == 1) {	# Print only unique alignment
				$single_unique_alignments++;	# Increment unique alignments

				if ($format =~ m/^sam$/i) {
					&printReadSAM($ofh, $good_paths1[0], $mate1, 1);
				} # end of if statement
				else {
					&printReadGFF3($ofh, $good_paths1[0], $mate1, 1, $source, sprintf("SE_%s", ++$match_id));
				} # End of else statement
			} # end of else if statement
		} # end of if statement

		if (!$asFragment && scalar(@good_paths2) > 0) {	# Need to print mate 2 as singleton
			$single_alignments++;	# Increment singletons count

			if (!$best && !$unique) {	# Print all possible paths
				if ($format =~ m/^sam$/i) {	# Print sam output
					for (my $i=0; $i < scalar(@good_paths2); $i++) {
						&printReadSAM($ofh, $good_paths2[$i], $mate2, 2);
					} # end of for loop
				} # end of if statmeent
				else {	# Print gff3 output
					for (my $i=0; $i < scalar(@good_paths2); $i++) {
						&printReadGFF3($ofh, $good_paths2[$i], $mate2, 2, $source, sprintf("SE_%s", ++$match_id));
					} # End of for loop
				} # End of else statement
			} # End of if statement
			elsif ($best && !$unique) {	# Print only the best possibel alignment
				my $best_path = &getBestPath($mate2);
				
				if (defined($best_path)) {
					$single_best_alignments++;

					if ($format =~ m/^sam$/i) {
						&printReadSAM($ofh, $best_path, $mate2, 2);
					} # end of if statement
					else {
						&printReadGFF3($ofh, $best_path, $mate2, 2, $source, sprintf("SE_%s", ++$match_id));
					} # End of else statement
				} # end of if statement

			} # end of else if statement
			elsif (!$best && $unique && scalar(@good_paths2) == 1) {	# Print only unique alignment
				$single_unique_alignments++;	# Increment unique alignments

				if ($format =~ m/^sam$/i) {
					&printReadSAM($ofh, $good_paths2[0], $mate2, 2);
				} # end of if statement
				else {
					&printReadGFF3($ofh, $good_paths2[0], $mate2, 2, $source, sprintf("SE_%s", ++$match_id));
				} # End of else statement
			} # end of else if statement
		} # end of if statement
	} # end of while loop
	close ($fh);

	my $data;
	$data->{"paired_alignments"} = $paired_alignments;
	$data->{"paired_best_alignments"} = $paired_best_alignments;
	$data->{"paired_unique_alignments"} = $paired_unique_alignments;
	$data->{"single_alignments"} = $single_alignments;
	$data->{"single_best_alignments"} = $single_best_alignments;
	$data->{"single_unique_alignments"} = $single_unique_alignments;
	$data->{"fragment_id"} = $fragment_id;
	$data->{"match_id"} = $match_id;

	return $data;
} # end of sub parseGSNAP

# =============== MAIN PROGRAM STARTS HERE =============== #
my (@input, $output, $format, $lengthFile);
my (@mismatches, @tails, $idp, $ignoretail, $max_splice, $best, $unique, $source, $processors);
my ($paired_alignments, $paired_best_alignments, $paired_unique_alignments) = (0, 0, 0);
my ($single_alignments, $single_best_alignments, $single_unique_alignments) = (0, 0, 0);
my ($fragment_id, $match_id) = (0, 0);

my $starttime = timelocal(localtime(time));

my $result = &GetOptions("input|i=s{1,}" => \@input,
                         "format|f=s{1}" => \$format,
						 "output|o=s{1}" => \$output,
                         "mismatches|m|mm:i{1,2}" => \@mismatches,
						 "idp:i{1}" => \$idp,
						 "tail|t:i{1,2}" => \@tails,
						 "maxsplice:i{1}" => \$max_splice,
						 "best!" => \$best,
						 "unique!" => \$unique,
						 "ignoretail!" => \$ignoretail,
						 "source|s:s{1}" => \$source,
						 "processors|p:i{1}" => \$processors,
						 "length|l:s{1}" => \$lengthFile);

unless ($result && scalar(@input) > 0 && defined($format) && defined($output)) {
	print STDERR sprintf("\n");
	print STDERR sprintf("*** INCORRECT NUMBER OF ARGUMENTS ***\n");
	print STDERR sprintf("\n");
	print STDERR sprintf("USAGE:\n");
	print STDERR sprintf("   perl %s --input|-i <gsnap output files> --format <sam|gff3> --output|-o <output file> [--length <length file>] [OPTIONS]\n", $0);
	print STDERR sprintf("\n");
	print STDERR sprintf("WHERE:\n");
	print STDERR sprintf("   --input <gsnap output files>          : Path to GSNAP standard output files generated using single/paired-end alignment\n");
	print STDERR sprintf("   --format <sam|gff3>                   : Specify parsing output format. Accepted values are \"sam\" or \"gff3\". If SAM output\n");
	print STDERR sprintf("                                           format is specified, you must also specify the lengths file\n");
	print STDERR sprintf("   --length|-l <length file>             : If '--format sam' is specified, please specify the path to the plain text file\n");
	print STDERR sprintf("                                           containing reference sequence length information separated by a tab character.\n");
	print STDERR sprintf("                                           The first column contains the sequence name or identifier and second column contains\n");
	print STDERR sprintf("                                           the length of the sequence in base-pairs.\n");
	print STDERR sprintf("   --output <output file>                : Path where parsed results will be saved\n");
	print STDERR sprintf("\n");
	print STDERR sprintf("OPTIONS:\n");
	print STDERR sprintf("   --mismatches|-m|-mm <n> <length>      : Allow at most 'n' mismatches per 'length' of the read. Specify this option\n");
	print STDERR sprintf("                                           if there are variable lengths of the reads used for alignment. For instance\n");
	print STDERR sprintf("                                           if \"--mismatches 2 36\" is specified, this means that we are allowing 2\n");
	print STDERR sprintf("                                           mismatches per every 36 bp of the read. If read length is 75 bp, the total\n");
	print STDERR sprintf("                                           number of mismatches allowed is: CEILING((75 x 2) / 36) = 5 mismatches\n");
	print STDERR sprintf("                                           This is the default parsing option [DEFAULT: %d %d]\n", DEFAULT_MISMATCHES,
	                                                                 DEFAULT_MISMATCHES_LENGTH);
	print STDERR sprintf("   --mismatches|-m|-mm <n>               : Allow at most 'n' mismatches per read regardless of read length.\n");
	print STDERR sprintf("                                           This option is the default parsing option unless variable read\n");
	print STDERR sprintf("                                           length mismatch parsing is specified\n");
	print STDERR sprintf("   --idp <penalty>                       : INDEL penalty in terms of mismatches [DEFAULT: %d]\n", DEFAULT_IDP);
	print STDERR sprintf("                                           (Penalize as 1 mismatch for gap alignment and 1 mismatch for the whole\n");
	print STDERR sprintf("                                           INDEL stretch)\n");
	print STDERR sprintf("   --tail|-t <n>                         : Maximum number of constant nucleotides allowed as tails per read (front tail +\n");
	print STDERR sprintf("                                           end tail) disregarding read length\n");
	print STDERR sprintf("   --tail|-t <n> <length>                : Maximum number of nucleotides allowed as tails per read (front tail +\n");
	print STDERR sprintf("                                           end tail) based on the read length. For instance if \"--tail 5 75\" is\n");
	print STDERR sprintf("                                           specified, this means that we are allowing 5 bases as tails per every 75 bp\n");
	print STDERR sprintf("                                           of the read. If read length is 100 bp, the total number of tails allowed\n");
	print STDERR sprintf("                                           is: CEILING((100 * 5) / 75) = 7 bases. This is the default parsing\n");
	print STDERR sprintf("                                           option [DEFAULT: %d %d]\n", DEFAULT_TAIL, DEFAULT_TAIL_LENGTH);
	print STDERR sprintf("   --ignoretail|--noignoretail           : Specify if evaluation of read tails should or should not be considered during\n");
	print STDERR sprintf("                                           parsing. Default option if --noignoretails (i.e. evaluate read tails)\n");
	print STDERR sprintf("   --maxsplice <max. splice distance>    : Maximum splice distance allowed [DEFAULT: %s]\n", MAXIMUM_SPLICE_DISTANCE);
    print STDERR sprintf("   --best|-b|--nobest|-nob               : If specified, only parse best possible alignment [DEFAULT: --nobest]\n");
    print STDERR sprintf("   --unique|-u|--nounique|-nou           : If specified, only parse unique aligments [DEFAULT: --nounique]\n");
	print STDERR sprintf("   --source <string>                     : Source string to be included in GFF3 file. [DEFAULT: %s]\n", DEFAULT_SOURCE);
	print STDERR sprintf("   --processors|-p <count>               : Specify the number of processors to use for parsing [DEFAULT: %s]\n", DEFAULT_PROCESSORS_COUNT);
#	print STDERR sprintf("   --legacy                              : Specify this flag if attempting to parse GSNAP output produced by version\n");
#	print STDERR sprintf("                                           2011-10-16 or earlier\n");
	print STDERR sprintf("\n");
	print STDERR sprintf("VERSION: %s\n", VERSION);
	print STDERR sprintf("\n");
	exit();
} # End of unless statement

# Change format to lowercase
$format = lc($format);

# Checking format and length file
if ($format =~ m/^sam$/ && !defined($lengthFile)) {
	print STDERR sprintf("\n");
	print STDERR sprintf("INVALID OPTIONS:\n");
	print STDERR sprintf("   Please specify the reference length file required for SAM output\n");
	print STDERR sprintf("\n");
	exit();
} # end of if statement

# Checking best or unique alignments
if ($best && $unique) {
	print STDERR sprintf("\n");
	print STDERR sprintf("INVALID OPTIONS:\n");
	print STDERR sprintf("   --best and --unique options cannot be both specified\n");
	print STDERR sprintf("\n");
	exit();
} # End of if statement

# Assigning default mismatches parameters if omitted
if (scalar(@mismatches) == 0) {
	push(@mismatches, DEFAULT_MISMATCHES, DEFAULT_MISMATCHES_LENGTH);
} # End of if statement

# Assigning default tail parameters if omitted
if (scalar(@tails) == 0) {	# Default tails allowed
	push(@tails, DEFAULT_TAIL, DEFAULT_TAIL_LENGTH);
} # End of if statement

# Assigning default values
$idp = DEFAULT_IDP if (!defined($idp));		# Default INDEL penalty
$best = false if (!defined($best));			# default is to print all possible alignments unless --best is specified
$unique = false if (!defined($unique));		# default is to print all possible alignments unless --unique is specified
$source = DEFAULT_SOURCE if (!defined($source));		# Default source string for GFF3 output
$ignoretail = false if (!defined($ignoretail));	# default DOES NOT IGNORE TAILS, tails are counted as mismatches
#$legacy = false if (!defined($legacy));			# Assume that users are attempting to parse GSNAP output generated in release 2011-10-16 or later
$max_splice = MAXIMUM_SPLICE_DISTANCE if (!defined($max_splice));	# Default maximum splice distance allowed
$processors = DEFAULT_PROCESSORS_COUNT if (!defined($processors));	# Default number of processors to use

my %params;	# Gathering program parameters
$params{"input"} = join("\t", @input);
$params{"mismatches"} = join(" ", @mismatches);
$params{"idp"} = $idp;
$params{"best"} = $best;
$params{"unique"} = $unique;
$params{"tails"} = join(" ", @tails);
$params{"ignoretail"} = $ignoretail;
$params{"max_splice"} = $max_splice;
$params{"source"} = $source;
$params{"processors"} = $processors;
$params{"format"} = $format;
#$params{"legacy"} = $legacy;
$params{"lengthFile"} = $lengthFile if (defined($lengthFile));

# Open output handler
my $ofh = new FileHandle();
open ($ofh, sprintf(">%s", $output)) or die("Cannot open output file\n");

# print headers
if ($format =~ m/^sam$/i) {
	&printSAMHeader(\%params, $ofh);
} # End of if statement
else {
	&printGFF3Header(\%params, $ofh);
} # end of else statemetn

if ($processors == 1) {	# Uniprocessor parsing
	for (my $i=0; $i < scalar(@input); $i++) {
		my $data = &parseGSNAP(\%params, $input[$i], $ofh, $fragment_id, $match_id);

		# Accumulate totals
		$paired_alignments += $data->{"paired_alignments"};
		$paired_best_alignments += $data->{"paired_best_alignments"};
		$paired_unique_alignments += $data->{"paired_unique_alignments"};
		$single_alignments += $data->{"single_alignments"};
		$single_best_alignments += $data->{"single_best_alignments"};
		$single_unique_alignments += $data->{"single_unique_alignments"};
		$fragment_id = $data->{"fragment_id"};
		$match_id = $data->{"match_id"};
	} # end of for loop
} # end of if statemnet
else {	# Multiple processors parsing
	for (my $i=0; $i < scalar(@input); $i++) {
		my @tmpFiles = &splitInputFile($input[$i], $processors);

		my $manager = new Parallel::ForkManager($processors);
		my @pointers;	# Contains the parsed read counts

		# Data structure retrieval after fork
		$manager->run_on_finish (
			sub {
				my ($pid, $exit_code, $ident, $exit_signal, $core_dump, $data_structure_reference) = @_;
				push(@pointers, $data_structure_reference);
			} # end of sub
		);

		foreach my $f (@tmpFiles) {
			$manager->start and next;		# Do the fork
			
			# Create a temporary output handler
			my $tmpFH = new FileHandle();
			open ($tmpFH, sprintf(">%s.out", $f)) or die("Cannot create temporary output file handler\n");
			
			# Uncomment line below if want to print SAM headers in the temporary files
			#&printSAMHeader(\%params, $tmpFH);

			my $ptr = &parseGSNAP(\%params, $f, $tmpFH, $fragment_id, $match_id);
			unlink($f);		# Remove temporary file after completion
			close ($tmpFH);
			$manager->finish(0, $ptr);
		} # end of for each statement

		$manager->wait_all_children;		# Wait for all child processes to complete

		# Mergin output
		if ($format =~ m/^sam$/i) {
			&mergeTempSAMOutput($ofh, map { sprintf("%s.out", $_) } @tmpFiles);
		} # end of if statement
		else {
			&mergeTempGFF3Output($ofh, map { sprintf("%s.out", $_) } @tmpFiles);
		} # end of else statement

		# Accumuate totals
		foreach my $data (@pointers) {
			$paired_alignments += $data->{"paired_alignments"};
			$paired_best_alignments += $data->{"paired_best_alignments"};
			$paired_unique_alignments += $data->{"paired_unique_alignments"};
			$single_alignments += $data->{"single_alignments"};
			$single_best_alignments += $data->{"single_best_alignments"};
			$single_unique_alignments += $data->{"single_unique_alignments"};
		} # end of for each statement
	} # End of for loop
} # end of else statement

# Print final statistics of parsing
my $endtime = timelocal(localtime(time));

if ($format =~ /^sam$/) {
    close ($ofh);
    $ofh = new FileHandle();
    open ($ofh, sprintf(">%s.stats", $output)) or die("Cannot open output stats file\n");

    print $ofh sprintf("# Script: %s\n", $0);
    print $ofh sprintf("# Version: %s\n", VERSION);
    print $ofh sprintf("#\n");

    print $ofh sprintf("# Input Files\n");

    print $ofh sprintf("#     + GSNAP Files: (%s)\n", &formatNumber(scalar(@input)));
    foreach my $f (@input) {
        print $ofh sprintf("#          - %s\n", $f);
    } # end of for each statement

    print $ofh sprintf("#\n");
    print $ofh sprintf("# Reference length file: %s\n", $lengthFile);
    print $ofh sprintf("# Mismatches allowed: %s\n", join(" ", @mismatches));
    print $ofh sprintf("# INDEL penalty: %d\n", $idp);

    if ($ignoretail) {
        print $ofh sprintf("# Ignore tails: Yes\n");
    } # End of if statemnet
    else {
        if (scalar(@tails) == 1) {
            print $ofh sprintf("# Maximum uniform tails allowed: %s (front tail + end tail)\n", $tails[0]);
        } # end of if statement
        else {
            print $ofh sprintf("# Maximum variable tails allowed: %s %s (front tail + end tail, allow %d bases as tails per every %s bp)\n",
                                $tails[0], $tails[1], $tails[0], $tails[1]);
        } # end of if statement
    } # End of else statement

    print $ofh sprintf("# Maximum splice distance allowed: %s\n", $max_splice);
    print $ofh sprintf("# Parse all possible aligments: %s\n", !$best && !$unique ? "Yes" : "No");
    print $ofh sprintf("# Best alignment parsing: %s\n", $best ? "Yes" : "No");
    print $ofh sprintf("# Unique aligment parsing: %s\n", $unique ? "Yes" : "No");
    print $ofh sprintf("# Processors: %s\n", $processors);
#	print $ofh sprintf("# Legacy Output Support: %s\n", $legacy ? "Yes" : "No");
} # end of if statement

print $ofh sprintf("#\n");

if ($single_alignments != 0) {
	print $ofh sprintf("#\n");
	print $ofh sprintf("# Total singleton reads aligned: %s\n", &formatNumber($single_alignments));
	
	if ($best) {
		print $ofh sprintf("# Total 'best' singleton reads aligned: %s (%2.1f%%)\n", &formatNumber($single_best_alignments), 
						  ($single_best_alignments / $single_alignments) * 100);
	} # end of if statemnet

	if ($unique) {
		print $ofh sprintf("# Total 'unique' singleton reads aligned: %s (%2.1f%%)\n", &formatNumber($single_unique_alignments),
						  ($single_unique_alignments / $single_alignments) * 100);
	} # end of if statement
} # end of if statement

if ($paired_alignments != 0) {
	print $ofh sprintf("# Total fragments aligned: %s (%s reads)\n", &formatNumber($paired_alignments), &formatNumber($paired_alignments * 2));

	if ($best) {
		print $ofh sprintf("# Total 'best' fragments aligned: %s (%s reads, %2.1f%%)\n", 
						  &formatNumber($paired_best_alignments), &formatNumber($paired_best_alignments * 2),
						  (($paired_best_alignments * 2) / ($paired_alignments * 2)) * 100);
	} # end of if statement

	if ($unique) {
		print $ofh sprintf("# Total 'unique' fragments aligned: %s (%s reads, %2.1f%%)\n", 
						  &formatNumber($paired_unique_alignments), &formatNumber($paired_unique_alignments * 2),
						  (($paired_unique_alignments * 2) / ($paired_alignments * 2)) * 100);
	} # end of if statement
} # end of if statement

print $ofh sprintf("#\n");
print $ofh sprintf("# Total aligned reads: %s\n", &formatNumber(($paired_alignments * 2) + $single_alignments));

if ($single_alignments + $paired_alignments != 0) {
	if ($best) {
		print $ofh sprintf("# Total 'best' aligned reads: %s (%2.1f%%)\n", 
						   &formatNumber(($paired_best_alignments * 2) + $single_best_alignments),
						   ((($paired_best_alignments * 2) + $single_best_alignments) / (($paired_alignments * 2) + $single_alignments)) * 100);
	} # end of if statement

	if ($unique) {
		print $ofh sprintf("# Total 'unique' aligned reads: %s (%2.1f%%)\n", 
						   &formatNumber(($paired_unique_alignments * 2) + $single_unique_alignments),
						   ((($paired_unique_alignments * 2) + $single_unique_alignments) / (($paired_alignments * 2) + $single_alignments)) * 100);
	} # end of if statement
} # End of if statement

print $ofh sprintf("#\n");
print $ofh sprintf("# Run-Time: %s\n", &formatTime($endtime - $starttime));
close ($ofh);	# Close final output file
