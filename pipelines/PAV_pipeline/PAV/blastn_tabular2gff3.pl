#!/usr/bin/perl -w

# Author: Eddy Yeh
# Date: 2013.02.04
#
# Description: This script parses the tabular output of BLASTN and converts alignments
#              in GFF3 format
#
# Change Log v1.5 -- 2013.06.03 (Eddy)
#  - Fixed negative numbers in overhang values
#  - Added tails front and tails end values when parsing
#
# Change Log v1.4 -- 2013.05.07 (Eddy)
#  - Added output of "overhang" bases
#  - Added program parameter "align" to control for minimum number of bases aligned
#  - Include number of bases aligned in GFF3 output's attribute field
#
# Change log v1.3 -- 2013.02.04 (Eddy)
#  - Changed how alignments are evaluated. If query sequences tails goes beyond the end of the subject
#    sequence, the overhang is no longer considered as tails
#  - Added/Changed program parameter -query_length and -subject_length
#
# Change Log v1.2 -- 2010.03.05 (Eddy)
#  - Added --unique argument to filter only unique hits
#
# Change Log v1.1 -- 2010.01.04 (Eddy)
#   - Added --best argument to filter only the best hits based on BLASTN score value and
#     identity, coverage, and tails criterias
#
# Change Log v1.0 -- 2009.10.06 (Eddy)
#   - Initial implementation of this script
#

use strict;
use warnings;
use FileHandle;
use Getopt::Long;

use Schnablelab::Tools;

use constant VERSION => "1.5 (2013.06.10)";
use constant true => 1;
use constant false => 0;
use constant DEFAULT_MIN_IDENTITY => 0.95;			# >=95% identity required
use constant DEFAULT_MIN_COVERAGE => 0.90;			# >=90% coverage required
use constant DEFAULT_MAX_TAILS => 20;				# <=20 bp tails allowed
use constant DEFAULT_MIN_ALIGNED_BASES => 100;		# Aligned region must be >=100 bp long
use constant DEFAULT_SOURCE => "BlastN";
use constant DEFAULT_FEATURE => "alignment";

my ($min_ident, $min_cvg, $max_tails, $min_align, $queryLengthFile, $subjectLengthFile, $ignore_tails, $blastFile, $source, $feature, $best, $unique, $output);

my $result = &GetOptions("queryLength|ql=s{1}" => \$queryLengthFile,
                         "subjectLength|sl=s{1}" => \$subjectLengthFile,
						 "blast|b=s{1}" => \$blastFile,
						 "output|out|o=s{1}" => \$output,
						 "indentity|ident|i:f{1}" => \$min_ident,
						 "coverage|cvg|c:f{1}" => \$min_cvg,
						 "align|a:i{1}" => \$min_align,
						 "tail|t:i{1}" => \$max_tails,
						 "ignoreTails|it!" => \$ignore_tails,
						 "source|s:s{1}" => \$source,
						 "feature|f:s{1}" => \$feature,
						 "best!" => \$best,
						 "unique!" => \$unique);

unless ($result && defined($queryLengthFile) && defined($subjectLengthFile) && defined($blastFile) && defined($output)) {
	print STDERR sprintf("\n");
	print STDERR sprintf("USAGE:\n");
	print STDERR sprintf("   perl %s --queryLength <query length file> --subjectLength <subject length file> \\\n", $0);
	print STDERR sprintf("           --blast <tabular blast file> --output <out> [OPTIONS]\n");
	print STDERR sprintf("\n");
	print STDERR sprintf("WHERE:\n");
	print STDERR sprintf("   --queryLength|-ql <file>                : Two column plain text file sepeatated by tabs, the first column is the query ID\n");
	print STDERR sprintf("                                             and the second column is the query lenght in base pairs\n");
	print STDERR sprintf("   --subjectLength|-sl <file>              : Two column plain text file separated by tabs, the  first column os the subject ID\n");
	print STDERR sprintf("                                             and the second column is the subject length in base pairs\n");
	print STDERR sprintf("   --blast|-b <file>                       : Output file generated by BlastN in tabular form\n");
	print STDERR sprintf("   --output|--out|-o <file>                : Path to file where GFF3 parsed output will be saved\n");
	print STDERR sprintf("\n");
	print STDERR sprintf("OPTIONS:\n");
	print STDERR sprintf("   --identity|--ident|-i <float>           : Minimum percent identity (0.0 ~ 1.0) to allow in the alignment\n");
	print STDERR sprintf("                                             [DEFAULT: %2.2f]\n", DEFAULT_MIN_IDENTITY);
	print STDERR sprintf("   --coverage|--cvg|-c <floag>             : Minimum percent coverage of query sequence (0.0 ~ 1.0) that must\n");
	print STDERR sprintf("                                             be aligned [DEFAULT: %2.2f]\n", DEFAULT_MIN_COVERAGE);
	print STDERR sprintf("   --align|-a <int>                        : Specify the minimum number of bases that must be aligned [DEFAULT: %s]\n", DEFAULT_MIN_ALIGNED_BASES);
	print STDERR sprintf("   --tail|-t <num>                         : Maximum number of base pairs allowed as tails [DEFAULT: %s]\n", DEFAULT_MAX_TAILS);
	print STDERR sprintf("   --source <string>                       : Source string to be included in the GFF3 output [DEFAULT: %s]\n", DEFAULT_SOURCE);
	print STDERR sprintf("   --feature <string>                      : Feature string to be included in the GFF3 output [DEFAULT: %s]\n", DEFAULT_FEATURE);
	print STDERR sprintf("   --ignoreTails|-it|--noignoreTails|-noit : If enabled, tail regions (overhangs) in the alignment are ignored\n");
	print STDERR sprintf("                                             during the filtering process [DEFAULT: --noignoreTails]\n");
	print STDERR sprintf("   --best|--nobest                         : If enabled, resolves best possible location of the query sequence\n");
	print STDERR sprintf("                                             BlastN score value [DEFAULT: --nobest]\n");
	print STDERR sprintf("   --unique|--nounique                     : If enabled, only query sequences that align uniquely that passed the\n");
	print STDERR sprintf("                                             filtering criterias will be included in the output [DEFAULT: --nounique]\n");
	print STDERR sprintf("\n");
	print STDERR sprintf("NOTES:\n");
	print STDERR sprintf("   (1) --best and --unique options cannot be both enabled. Default program behavior is --nobest and --nounique which\n");
	print STDERR sprintf("       outputs all possibel alignments that passed the filtering criterias\n");
	print STDERR sprintf("\n");
	print STDERR sprintf("VERSION: %s\n", VERSION);
	print STDERR sprintf("\n");
	exit();
} # endo f unless statement

# Default program paramters
$ignore_tails = false if (!defined($ignore_tails));
$best = false if (!defined($best));
$unique = false if (!defined($unique));
$min_ident = DEFAULT_MIN_IDENTITY if (!defined($min_ident) || $min_ident !~ m/^\d+(\.\d+)?$/);
$min_cvg = DEFAULT_MIN_COVERAGE if (!defined($min_cvg) || $min_cvg !~ m/^\d+(\.\d+)?$/);
$max_tails = DEFAULT_MAX_TAILS if (!defined($max_tails) || $max_tails !~ m/^\d+$/);
$min_align = DEFAULT_MIN_ALIGNED_BASES if (!defined($min_align) || $min_align !~ m/^\d+$/);
$source = DEFAULT_SOURCE if (!defined($source));
$feature = DEFAULT_FEATURE if (!defined($feature));

if ($best && $unique) {
	print STDERR sprintf("\n");
	print STDERR sprintf("ERROR: Program paramters --best and --unique cannot be both specified\n");
	print STDERR sprintf("\n");
	exit();
} # end of if statement

# Create output handler
my $ofh = new FileHandle();
open ($ofh, sprintf(">%s", $output)) or die("Cannot create output file\n");
print $ofh sprintf("##gff-version\t3\n");
print $ofh sprintf("# %s\n", scalar(localtime(time)));
print $ofh sprintf("#\n");
print $ofh sprintf("# SCRIPT: %s\n", $0);
print $ofh sprintf("# VERSION: %s\n", VERSION);
print $ofh sprintf("#\n");
print $ofh sprintf("# Tabular BlastN File: %s\n", $blastFile);
print $ofh sprintf("# Query Length File: %s\n", $queryLengthFile);
print $ofh sprintf("# Subject Length File: %s\n", $subjectLengthFile);
print $ofh sprintf("# Minimum Query Identity: %2.2f\n", $min_ident);
print $ofh sprintf("# Minimum Query Coverage: %2.2f\n", $min_cvg);
print $ofh sprintf("# Minimum Number of Bases Aligned: %s\n", $min_align);
print $ofh sprintf("# Maximum Query Tails Allowed: %s\n", $ignore_tails ? "IGNORED" : sprintf("%s bp", $max_tails));

if (!$best && !$unique) {
	print $ofh sprintf("# Hits Parsing: ALL [parse all possible alignments]\n");
} # end of if statement
elsif (!$best && $unique) {
	print $ofh sprintf("# Hits Parsing: UNIQUE [parse unique alignments only]\n");
} # end of else if statement
elsif ($best && !$unique) {
	print $ofh sprintf("# Hits Parsing: BEST [parse best alignment based on BlastN score]\n");
} # end of else if staement
print $ofh sprintf("#\n");

# Reading query lengh file
my %queryLengths;
my $fh = new FileHandle();
open ($fh, $queryLengthFile) or die("Cannot open query length file\n");
while (<$fh>) {
	chomp;
	if ($_ !~ m/^#/) {
		my ($id, $bp) = split(/\t/, $_);
		$queryLengths{$id} = $bp;
	} # end of if statement
} # end of while loop
close ($fh);

# Reading subject length file
my %subjectLengths;
$fh = new FileHandle();
open ($fh, $subjectLengthFile) or die("Cannot open subject length file\n");
while (<$fh>) {
	chomp;
	if ($_ !~ m/^#/) {
		my ($id, $bp) = split(/\t/, $_);
		$subjectLengths{$id} = $bp;
	} # end of if statement
} # end of while loop
close ($fh);

# Reading blastN file
my $prevQuery;
my %hits;
$fh = new FileHandle();
open ($fh, $blastFile) or die("Cannot open tabular BlastN file\n");
while (<$fh>) {
	chomp;
	if (length($_) != 0 && $_ !~ m/^#/) {
		my ($query, $subject, $ident, $align, $mismatch, $gap, $qstart, $qend, $sstart, $send, $eval, $score) = split(/\t/, $_);
		$score = &trim($score);
		my $strand = "+";	# Default strand is "+"

		if ($sstart > $send) {
			$strand = "-";
			my $tmp = $sstart;
			$sstart = $send;
			$send = $tmp;
		} # end of if statement

		if (defined($prevQuery) && $prevQuery ne $query) {	# print previous record
			my @keys = sort {$b <=> $a} keys %hits;

			if ($best) {
				my @values = split(/\n/, $hits{$keys[0]});
				print $ofh sprintf("%s\n", $values[0]);
			} # end of if statment
			elsif ($unique) {
				my @values = split(/\n/, $hits{$keys[0]});
				# Print only if there is only 1 alignment
				print $ofh sprintf("%s\n", $values[0]) if (scalar(@keys) == 1 && scalar(@values) == 1);
			} # end of else if statemetn
			else {	# Print all possible
				foreach my $k (@keys) {
					print $ofh sprintf("%s\n", $hits{$k});
				} # End of for each statement
			} # end of else statement

			# Reset
			undef($prevQuery);
			%hits = ();
		} # end of if statemetn

		# Get query and subject lengths
		my $ql = $queryLengths{$query};
		my $sl = $subjectLengths{$subject};
		
		# Recompute tails within subject boundaries
		my $tails_f = &min($qstart - 1, $sstart - 1);
		my $tails_e = &min($ql - $qend, $sl - $send);
		my $tails = $tails_f + $tails_e;
		#my $tails = &min($qstart - 1, $sstart - 1) + &min($ql - $qend, $sl - $send);	# compute tails ignroing sequences beyond subject boundaries
		$ql = $ql - $tails;	# modify query length after ignoring sequences beyond subject boundaries

		my $aligned = $qend - $qstart + 1;	# Unique new aligned bases ignoring gaps
		my $identity = $ident / 100;
		my $coverage = $aligned / $ql;
		my $overhang = $queryLengths{$query} - $aligned - $tails;

		# Checking
		if ( ($ignore_tails && $identity >= $min_ident && $coverage >= $min_cvg && $aligned >= $min_align) ||
		     ($identity >= $min_ident && $coverage >= $min_cvg && $tails <= $max_tails && $aligned >= $min_align) ) {
			 
			 my $outstr = sprintf("%s\t%s\t%s\t%s\t%s\t%2.4f\t%s\t%s\tName=%s;Note=Length: %s bp, Identity: %2.4f, Coverage: %2.4f, Aligned: %s bp, Tails: %d bp (Tails Front: %s bp + Tails End: %s bp), Overhang: %d bp, Score: %s;Target=%s %s %s",
				   				  $subject, $source, $feature, $sstart, $send, $identity, $strand, ".",
				   				  $query, $queryLengths{$query}, $identity, $coverage, $aligned, $tails, $tails_f, $tails_e, $overhang, $score, $query, $qstart, $qend);
			$prevQuery = $query;
			
			if (exists $hits{$score}) {
				$hits{$score} .= sprintf("\n%s", $outstr);
			} # end of if statement
			else {
				$hits{$score} = $outstr;
			} # End of if statement
		} # End of if statement
	} # End of if statemnet
} # end of while loop
	
# Very last record
if (defined($prevQuery)) {
	my @keys = sort {$b <=> $a} keys %hits;

	if ($best) {
		my @values = split(/\n/, $hits{$keys[0]});
		print $ofh sprintf("%s\n", $values[0]);
	} # end of if statment
	elsif ($unique) {
		my @values = split(/\n/, $hits{$keys[0]});
		# Print only if there is only 1 alignment
		print $ofh sprintf("%s\n", $values[0]) if (scalar(@keys) == 1 && scalar(@values) == 1);
	} # end of else if statemetn
	else {	# Print all possible
		foreach my $k (@keys) {
			print $ofh sprintf("%s\n", $hits{$k});
		} # End of for each statement
	} # end of else statement
} # end of if statemetn
close ($fh);
close ($ofh);
